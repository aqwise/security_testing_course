export interface QuizQuestion {
    question: string;
    answers: string[];
    correctAnswerIndex: number;
    explanation?: string;
    link?: {
        label: string;
        url: string;
    };
}

export const quizQuestions: QuizQuestion[] = [
    {
        question: "Что такое Broken Access Control?",
        answers: [
            "Уязвимость, позволяющая пользователям выполнять действия за пределами своих прав и получать доступ к ресурсам",
            "Уязвимость, позволяющая перехватывать и расшифровывать защищённый SSL/TLS трафик",
            "Ошибка конфигурации веб-сервера, приводящая к некорректной работе",
            "Способность внедрять вредоносный SQL-код через поля ввода формы",
            "Уязвимость межсайтового выполнения скриптов в браузере",
            "Ошибка в логике аутентификации пользователей",
            "Проблема с шифрованием данных в базе данных"
        ],
        correctAnswerIndex: 0,
        explanation: "Broken Access Control — это когда пользователь может выполнить действия или получить доступ к данным, к которым у него не должно быть прав. Это самая распространённая уязвимость согласно OWASP Top 10 2021.",
        link: {
            label: "OWASP: Broken Access Control",
            url: "https://owasp.org/Top10/A01_2021-Broken_Access_Control/"
        }
    },
    {
        question: "Что означает аббревиатура IDOR?",
        answers: [
            "Insecure Direct Object References — небезопасные прямые ссылки на объекты без проверки прав",
            "Integrated Development Object Runtime — среда выполнения объектов в разработке",
            "Internal Data Output Request — запрос внутреннего вывода данных",
            "Instant Denial Of Resource — мгновенный отказ в предоставлении ресурса",
            "Interactive Database Object Retrieval — интерактивное извлечение объектов из БД",
            "Indexed Direct Object Reference — индексированная ссылка на объект",
            "Incoming Data Origin Routing — маршрутизация источника входящих данных"
        ],
        correctAnswerIndex: 0,
        explanation: "IDOR (Insecure Direct Object References) — это когда приложение использует пользовательский ввод для прямого доступа к объектам (файлам, записям БД) без проверки прав.",
        link: {
            label: "PortSwigger: IDOR",
            url: "https://portswigger.net/web-security/access-control/idor"
        }
    },
    {
        question: "Какой пример описывает вертикальное повышение привилегий (Vertical Privilege Escalation)?",
        answers: [
            "Обычный пользователь получает доступ к административной панели управления системой",
            "Пользователь A получает доступ к приватным фотографиям Пользователя B (того же уровня прав)",
            "Пользователь успешно редактирует свой собственный профиль",
            "Администратор создаёт нового пользователя через админ-панель",
            "Пользователь изменяет свой аватар и описание",
            "Гость просматривает публичную страницу без авторизации",
            "Модератор банит пользователя согласно своим правам"
        ],
        correctAnswerIndex: 0,
        explanation: "Вертикальное повышение привилегий — это когда пользователь получает доступ к функционалу более привилегированной роли (например, обычный пользователь → администратор).",
        link: {
            label: "PortSwigger: Vertical Privilege Escalation",
            url: "https://portswigger.net/web-security/access-control"
        }
    },
    {
        question: "Какой пример описывает горизонтальное повышение привилегий (Horizontal Privilege Escalation)?",
        answers: [
            "Пользователь A читает личные сообщения Пользователя B, находясь на том же уровне прав",
            "Пользователь A повышает свои права до уровня администратора",
            "Гость регистрируется на сайте и создаёт аккаунт",
            "Администратор выполняет резервное копирование базы данных",
            "Пользователь восстанавливает свой забытый пароль",
            "Модератор удаляет комментарий другого модератора",
            "Пользователь просматривает публичные профили других пользователей"
        ],
        correctAnswerIndex: 0,
        explanation: "Горизонтальное повышение привилегий — доступ к ресурсам другого пользователя того же уровня (например, пользователь видит данные другого пользователя).",
        link: {
            label: "PortSwigger: Horizontal Privilege Escalation",
            url: "https://portswigger.net/web-security/access-control"
        }
    },
    {
        question: "Какой основной принцип защиты от Broken Access Control?",
        answers: [
            "Проверка прав доступа на серверной стороне для каждого запроса и ресурса",
            "Скрытие административных ссылок и кнопок в пользовательском интерфейсе",
            "Использование исключительно протокола HTTPS для всех соединений",
            "Полное отключение JavaScript в браузере пользователя",
            "Применение сложных паролей для всех учётных записей",
            "Использование капчи на каждой странице приложения",
            "Ограничение длины URL-адресов до 100 символов"
        ],
        correctAnswerIndex: 0,
        explanation: "Главный принцип — проверять права доступа на сервере для каждого действия. Скрытие UI-элементов недостаточно, так как атакующий может напрямую обратиться к API.",
        link: {
            label: "OWASP: Access Control Prevention",
            url: "https://cheatsheetseries.owasp.org/cheatsheets/Authorization_Cheat_Sheet.html"
        }
    },
    {
        question: "Можно ли полагаться на то, что пользователь не знает URL админки (Security by Obscurity)?",
        answers: [
            "Нет, это ненадёжный метод защиты — атакующие используют сканеры и словари для поиска скрытых путей",
            "Да, если URL достаточно длинный и сложный для запоминания",
            "Да, но только если приложение развёрнуто в корпоративной сети",
            "Нет, но только потому что URL можно угадать методом брутфорса",
            "Да, это стандартная практика защиты административных интерфейсов",
            "Нет, но только если используется HTTP вместо HTTPS",
            "Да, если дополнительно отключить индексацию в robots.txt"
        ],
        correctAnswerIndex: 0,
        explanation: "Security by Obscurity — ненадёжная защита. Атакующие используют инструменты (DirBuster, ffuf) и стандартные пути (/admin, /administrator). Всегда нужна проверка прав доступа.",
        link: {
            label: "OWASP: Security by Obscurity",
            url: "https://owasp.org/www-community/controls/Blocking_Brute_Force_Attacks"
        }
    },
    {
        question: "Что такое Forced Browsing в контексте контроля доступа?",
        answers: [
            "Попытка доступа к скрытым ресурсам и страницам путём прямого ввода или угадывания URL",
            "Принудительное автоматическое обновление страницы браузером каждые несколько секунд",
            "Автоматическое перенаправление пользователя с HTTP на HTTPS протокол",
            "Блокировка всплывающих окон и рекламы встроенными средствами браузера",
            "Использование закладок браузера для быстрого доступа к страницам",
            "Навигация по сайту только через главное меню",
            "Открытие нескольких вкладок одновременно в браузере"
        ],
        correctAnswerIndex: 0,
        explanation: "Forced Browsing — это попытка доступа к ресурсам (файлам, админ-панели) путём прямого ввода URL, минуя навигацию. Атакующий перебирает типичные пути.",
        link: {
            label: "PortSwigger: Forced Browsing",
            url: "https://portswigger.net/kb/issues/00600400_forced-browsing"
        }
    },
    {
        question: "Какой инструмент Burp Suite автоматизирует поиск уязвимостей контроля доступа?",
        answers: [
            "Autorize — расширение для автоматической проверки прав доступа разных пользователей",
            "Decoder — инструмент для декодирования и кодирования данных",
            "Comparer — утилита для сравнения двух блоков данных",
            "Sequencer — анализатор качества генерации случайных токенов",
            "Repeater — инструмент для повторной отправки HTTP-запросов",
            "Intruder — модуль для автоматизации атак и фаззинга",
            "Scanner — автоматический сканер уязвимостей веб-приложений"
        ],
        correctAnswerIndex: 0,
        explanation: "Autorize — популярное расширение Burp Suite, которое автоматически повторяет запросы от имени пользователя с низкими привилегиями и сравнивает с ответами привилегированного пользователя.",
        link: {
            label: "Autorize Extension",
            url: "https://github.com/PortSwigger/autorize"
        }
    },
    {
        question: "Почему изменение ID в URL (например, /users/123 → /users/124) может быть опасным?",
        answers: [
            "Это может привести к просмотру или изменению данных другого пользователя при отсутствии проверки прав",
            "Это создаёт чрезмерную нагрузку на базу данных и снижает производительность",
            "Это ломает механизм кеширования браузера и CDN-сервисов",
            "Это автоматически изменяет дизайн и тему оформления страницы",
            "Это приводит к дублированию данных в базе данных",
            "Это вызывает ошибки валидации на стороне клиента",
            "Это нарушает SEO-оптимизацию и индексацию поисковиками"
        ],
        correctAnswerIndex: 0,
        explanation: "Это классический пример IDOR. Если сервер не проверяет, имеет ли текущий пользователь право на просмотр записи с ID=124, произойдёт утечка данных.",
        link: {
            label: "PortSwigger: IDOR Labs",
            url: "https://portswigger.net/web-security/access-control/lab-user-id-controlled-by-request-parameter"
        }
    },
    {
        question: "Является ли сокрытие кнопки 'Удалить' в UI достаточной мерой защиты?",
        answers: [
            "Нет, пользователь может отправить HTTP-запрос напрямую к API, минуя интерфейс",
            "Да, если пользователь не видит кнопку, он не сможет выполнить действие",
            "Да, если использовать CSS-свойство display: none вместо visibility: hidden",
            "Да, но только для мобильных приложений и устройств",
            "Нет, но только если приложение использует REST API",
            "Да, если дополнительно отключить JavaScript в браузере",
            "Да, если кнопка скрыта через серверный рендеринг"
        ],
        correctAnswerIndex: 0,
        explanation: "Скрытие UI-элементов — это только улучшение UX, но не мера безопасности. Атакующий может перехватить и модифицировать запрос через Burp Suite, даже не видя кнопки.",
        link: {
            label: "OWASP: Client-Side Access Control",
            url: "https://owasp.org/www-community/Access_Control"
        }
    },
    {
        question: "Что означает принцип 'Deny by Default' (Запрет по умолчанию)?",
        answers: [
            "Политика, при которой доступ к ресурсам запрещён всем, кому он не разрешён явно",
            "Автоматическая блокировка всех IP-адресов из других стран и регионов",
            "Полный запрет на использование cookies и сессий в приложении",
            "Автоматический бан пользователей после трёх неудачных попыток входа",
            "Запрет на использование любых сторонних библиотек и зависимостей",
            "Блокировка всех HTTP-методов кроме GET и POST",
            "Отключение всех функций приложения до явной активации администратором"
        ],
        correctAnswerIndex: 0,
        explanation: "'Deny by Default' — фундаментальный принцип безопасности. Вместо blacklist (запрещать конкретное) используйте whitelist (разрешать только конкретное).",
        link: {
            label: "OWASP: Deny by Default",
            url: "https://cheatsheetseries.owasp.org/cheatsheets/Authorization_Cheat_Sheet.html"
        }
    },
    {
        question: "Как UUID помогает в защите от IDOR?",
        answers: [
            "Делает идентификаторы трудноугадываемыми, но не заменяет необходимость проверки прав доступа",
            "Автоматически шифрует все данные в базе данных и памяти",
            "Автоматически проверяет права доступа для каждого запроса",
            "Значительно ускоряет работу индексов базы данных и запросов",
            "Полностью исключает возможность IDOR-атак без дополнительной защиты",
            "Заменяет необходимость в системе аутентификации и авторизации",
            "Автоматически генерирует уникальные пароли для пользователей"
        ],
        correctAnswerIndex: 0,
        explanation: "UUID (Globally Unique Identifier) делает перебор ID практически невозможным, но если UUID ут екает (например, из URL или логов), атакующий всё равно может им воспользоваться. Проверка прав обязательна!",
        link: {
            label: "PortSwigger: Unpredictable IDs",
            url: "https://portswigger.net/web-security/access-control/lab-user-id-controlled-by-request-parameter-with-unpredictable-user-ids"
        }
    },
    {
        question: "Может ли манипуляция с JWT токеном привести к нарушению контроля доступа?",
        answers: [
            "Да, если сервер не проверяет подпись токена или принимает алгоритм 'none'",
            "Нет, JWT всегда надёжно защищён криптографической подписью",
            "Только если JWT токен истёк и требуется его обновление",
            "Нет, это проблема аутентификации, а не авторизации и контроля доступа",
            "Да, но только если JWT хранится в localStorage вместо cookies",
            "Нет, JWT невозможно модифицировать без знания секретного ключа",
            "Только если используется алгоритм RS256 вместо HS256"
        ],
        correctAnswerIndex: 0,
        explanation: "Если сервер некорректно валидирует JWT (не проверяет подпись, принимает 'none'), атакующий может изменить claims (например, role: admin) и получить повышенные права.",
        link: {
            label: "JWT Security Best Practices",
            url: "https://cheatsheetseries.owasp.org/cheatsheets/JSON_Web_Token_for_Java_Cheat_Sheet.html"
        }
    },
    {
        question: "Что такое Path Traversal (обход пути)?",
        answers: [
            "Атака, позволяющая выходить за пределы разрешённой директории используя последовательности ../",
            "Метод оптимизации маршрутизации запросов в сетевой инфраструктуре",
            "Функция браузера для автоматического перехода по внешним ссылкам",
            "Тип CSS-анимации для плавного перемещения элементов на странице",
            "Алгоритм поиска кратчайшего пути в графе зависимостей",
            "Метод навигации пользователя по истории посещённых страниц",
            "Техника SEO-оптимизации для улучшения индексации сайта"
        ],
        correctAnswerIndex: 0,
        explanation: "Path Traversal (Directory Traversal) — атака с использованием '../../' для выхода из текущей директории и доступа к файлам выше (например, /etc/passwd на Linux).",
        link: {
            label: "PortSwigger: Path Traversal",
            url: "https://portswigger.net/web-security/file-path-traversal"
        }
    },
    {
        question: "Какие HTTP-методы часто забывают защитить разработчики, реализуя проверку только для GET?",
        answers: [
            "POST, PUT, DELETE, PATCH — все методы изменения данных требуют одинаковой защиты",
            "Только метод POST, так как он используется для отправки форм",
            "Только метод HEAD, так как он возвращает только заголовки",
            "OPTIONS, TRACE, CONNECT — служебные методы HTTP-протокола",
            "Только метод GET с параметрами в query string",
            "LINK и UNLINK — устаревшие методы для управления ссылками",
            "Только методы, начинающиеся с X- (пользовательские методы)"
        ],
        correctAnswerIndex: 0,
        explanation: "Распространённая ошибка — проверять права только для GET-запросов. PUT, POST, DELETE, PATCH должны иметь те же проверки. Атакующий может просто изменить метод запроса.",
        link: {
            label: "PortSwigger: Method-based Access Control",
            url: "https://portswigger.net/web-security/access-control/lab-method-based-access-control-can-be-circumvented"
        }
    },
    {
        question: "Где должна выполняться проверка прав доступа?",
        answers: [
            "На backend-сервере обязательно, на frontend — опционально для улучшения UX",
            "Только на frontend для быстрой обратной связи с пользователем",
            "Только на backend, frontend вообще не должен знать о правах",
            "В хранимых процедурах базы данных для максимальной безопасности",
            "В middleware веб-сервера (Nginx, Apache) до приложения",
            "На уровне сетевого файрвола перед веб-сервером",
            "В браузере пользователя с помощью JavaScript"
        ],
        correctAnswerIndex: 0,
        explanation: "Проверка прав обязательна на backend. Frontend может скрывать элементы для UX, но это не защита — атакующий может обойти клиентский код.",
        link: {
            label: "OWASP: Server-Side Authorization",
            url: "https://cheatsheetseries.owasp.org/cheatsheets/Authorization_Cheat_Sheet.html"
        }
    },
    {
        question: "Какой HTTP-заголовок помогает предотвратить кеширование чувствительных данных браузером?",
        answers: [
            "Cache-Control: no-store, no-cache, must-revalidate — запрещает кеширование",
            "Server: Apache/2.4.41 — информация о версии веб-сервера",
            "Content-Type: application/json — тип содержимого ответа",
            "X-Powered-By: PHP/7.4 — информация о технологии backend",
            "Accept-Encoding: gzip, deflate — поддерживаемые методы сжатия",
            "User-Agent: Mozilla/5.0 — информация о браузере клиента",
            "X-Frame-Options: DENY — защита от clickjacking-атак"
        ],
        correctAnswerIndex: 0,
        explanation: "Cache-Control: no-store запрещает браузеру и прокси кешировать ответ. Это важно для страниц с личными данными, иначе следующий пользователь на общем компьютере увидит их.",
        link: {
            label: "MDN: Cache-Control",
            url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control"
        }
    },
    {
        question: "Что делать с недокументированными API-эндпоинтами (например, /debug, /test)?",
        answers: [
            "Отключить или защитить их на продакшене, так как они часто содержат уязвимости",
            "Оставить как есть, ими всё равно никто не пользуется в бою",
            "Просто скрыть их из документации Swagger и OpenAPI",
            "Использовать их для мониторинга и отладки в production",
            "Переименовать в более сложные названия для безопасности",
            "Сделать их доступными только через HTTPS протокол",
            "Добавить капчу на эти эндпоинты для защиты"
        ],
        correctAnswerIndex: 0,
        explanation: "Debug/test эндпоинты часто содержат избыточную информацию или функции без проверки прав. На продакшене их нужно отключить или защитить строгой аутентификацией.",
        link: {
            label: "OWASP: Security Misconfiguration",
            url: "https://owasp.org/Top10/A05_2021-Security_Misconfiguration/"
        }
    },
    {
        question: "Какой принцип нарушается, если всем пользователям даны права администратора?",
        answers: [
            "Принцип наименьших привилегий (Least Privilege) — давать только необходимые права",
            "Принцип открытости и прозрачности системы для всех",
            "Принцип глубокой защиты (Defense in Depth)",
            "Принцип KISS (Keep It Simple, Stupid)",
            "Принцип единственной ответственности (Single Responsibility)",
            "Принцип разделения обязанностей (Separation of Duties)",
            "Принцип DRY (Don't Repeat Yourself)"
        ],
        correctAnswerIndex: 0,
        explanation: "Least Privilege — пользователь должен иметь минимальный набор прав, необходимый для работы. Избыточные права увеличивают impact при компрометации.",
        link: {
            label: "OWASP: Least Privilege",
            url: "https://owasp.org/www-community/Access_Control"
        }
    },
    {
        question: "Как протестировать IDOR, если ID представлен сложным GUID?",
        answers: [
            "Зарегистрировать два аккаунта и попробовать использовать GUID второго в запросах первого",
            "Использовать брутфорс для перебора всех возможных GUID",
            "Это невозможно проверить при использовании GUID",
            "Применить SQL Injection для извлечения GUID из базы",
            "Использовать XSS для кражи GUID других пользователей",
            "Подождать утечки базы данных с GUID в даркнете",
            "Использовать квантовый компьютер для взлома GUID"
        ],
        correctAnswerIndex: 0,
        explanation: "GUID делает перебор нереальным, но не защищает от IDOR. Создайте два тестовых аккаунта, возьмите GUID пользователя B и попробуйте запросить его данные от имени A.",
        link: {
            label: "PortSwigger: Unpredictable IDs",
            url: "https://portswigger.net/web-security/access-control/lab-user-id-controlled-by-request-parameter-with-unpredictable-user-ids"
        }
    },
    {
        question: "Влияет ли CORS misconfiguration на контроль доступа?",
        answers: [
            "Да, это позволяет злоумышленнику читать данные с API от имени залогиненного пользователя",
            "Нет, CORS только управляет загрузкой шрифтов и изображений",
            "Только если приложение используется исключительно через HTTPS",
            "Нет, CORS — это только защитный механизм браузера",
            "Да, но только для WebSocket-соединений и SSE",
            "Нет, CORS влияет только на производительность загрузки",
            "Только если используется метод OPTIONS в preflight-запросах"
        ],
        correctAnswerIndex: 0,
        explanation: "Если CORS настроен как Access-Control-Allow-Origin: *, злоумышленник может создать страницу, которая от имени жертвы прочитает данные с вашего API.",
        link: {
            label: "PortSwigger: CORS Misconfiguration",
            url: "https://portswigger.net/web-security/cors"
        }
    },
    {
        question: "Какой HTTP-код обычно означает 'Доступ запрещён'?",
        answers: [
            "401 Unauthorized (не аутентифицирован) или 403 Forbidden (аутентифицирован, но нет прав)",
            "200 OK — успешный запрос с корректным ответом",
            "404 Not Found — ресурс не найден на сервере",
            "500 Internal Server Error — внутренняя ошибка сервера",
            "301 Moved Permanently — постоянное перенаправление",
            "418 I'm a teapot — сервер отказывается варить кофе",
            "504 Gateway Timeout — таймаут шлюза или прокси"
        ],
        correctAnswerIndex: 0,
        explanation: "401 — пользователь не залогинен. 403 — пользователь залогинен, но у него нет прав на ресурс. Важно различать эти коды для корректной обработки.",
        link: {
            label: "MDN: HTTP Status Codes",
            url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status"
        }
    },
    {
        question: "Что такое Parameter Tampering в контексте Broken Access Control?",
        answers: [
            "Изменение параметров запроса (id, price, role) для обхода логики и получения доступа",
            "Оптимизация параметров конфигурации базы данных для производительности",
            "Шифрование параметров URL с помощью Base64 или других алгоритмов",
            "Добавление новых параметров в GET-запрос для расширения функционала",
            "Удаление всех параметров из запроса для упрощения",
            "Автоматическая валидация параметров на стороне клиента",
            "Сжатие параметров для уменьшения размера HTTP-запроса"
        ],
        correctAnswerIndex: 0,
        explanation: "Parameter Tampering — изменение параметров (price=100 → price=1, role=user → role=admin) в запросе. Сервер должен валидировать все входные данные.",
        link: {
            label: "OWASP: Parameter Tampering",
            url: "https://owasp.org/www-community/attacks/Web_Parameter_Tampering"
        }
    },
    {
        question: "Если API возвращает 200 OK на запрос удаления, но запись не удаляется, это уязвимость?",
        answers: [
            "Нет, если действие не выполнено, это false positive, но плохая практика API design",
            "Да, это всегда считается Broken Access Control в любом случае",
            "Да, это Information Disclosure очень высокой критичности",
            "Это классический пример SQL Injection атаки",
            "Да, это обязательно приведёт к утечке данных",
            "Нет, 200 OK всегда означает успешное выполнение",
            "Это уязвимость CSRF, а не проблема доступа"
        ],
        correctAnswerIndex: 0,
        explanation: "Если сервер возвращает 200 OK, но действие не выполняется — это плохой API design, но не уязвимость. Однако это может маскировать реальную проблему контроля доступа.",
        link: {
            label: "REST API Best Practices",
            url: "https://restfulapi.net/http-status-codes/"
        }
    },
    {
        question: "Можно ли доверять данным из скрытых полей формы (hidden inputs)?",
        answers: [
            "Нет, пользователь может легко изменить их через DevTools или прокси-сервер типа Burp Suite",
            "Да, если пользователь не видит эти поля в интерфейсе",
            "Да, если используется метод POST вместо GET",
            "Да, если значения зашифрованы JavaScript на клиенте",
            "Нет, но только если поля содержат числовые значения",
            "Да, если форма защищена CSRF-токеном",
            "Да, если скрытое поле помечено атрибутом readonly"
        ],
        correctAnswerIndex: 0,
        explanation: "Hidden inputs — это просто HTML с display:none. Атакующий видит их в исходном коде и может модифицировать через DevTools или перехватив запрос.",
        link: {
            label: "OWASP: Client-Side Controls",
            url: "https://owasp.org/www-community/vulnerabilities/Unrestricted_File_Upload"
        }
    },
    {
        question: "Какая роль у Cookie 'SameSite' в контексте контроля доступа?",
        answers: [
            "Защита от CSRF-атак, предотвращая отправку cookies при межсайтовых запросах",
            "Автоматическое шифрование содержимого cookies",
            "Увеличение срока жизни cookies до 1 года",
            "Разрешение доступа к cookies через JavaScript",
            "Синхронизация cookies между разными доменами",
            "Защита от XSS-атак и кражи cookies",
            "Автоматическая ротация значений cookies"
        ],
        correctAnswerIndex: 0,
        explanation: "SameSite=Strict/Lax не позволяет браузеру отправлять cookies при запросах с других сайтов, что защищает от CSRF. Это дополнительная линия защиты помимо CSRF-токенов.",
        link: {
            label: "MDN: SameSite Cookies",
            url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie/SameSite"
        }
    },
    {
        question: "Что такое Role-Based Access Control (RBAC)?",
        answers: [
            "Система контроля доступа, где права назначаются ролям, а роли — пользователям",
            "Контроль доступа на основе IP-адресов пользователей",
            "Система доступа по времени суток и дням недели",
            "Ручное управление доступом для каждого отдельного файла",
            "Контроль доступа на основе геолокации пользователя",
            "Система доступа через биометрическую аутентификацию",
            "Контроль доступа на основе устройства пользователя"
        ],
        correctAnswerIndex: 0,
        explanation: "RBAC — популярная модель, где вместо назначения прав каждому пользователю создаются роли (admin, editor, viewer), а пользователям назначаются роли.",
        link: {
            label: "NIST: RBAC",
            url: "https://csrc.nist.gov/projects/role-based-access-control"
        }
    },
    {
        question: "Является ли проверка заголовка Referer надёжной защитой доступа?",
        answers: [
            "Нет, заголовок Referer может быть подделан или отсутствовать",
            "Да, это стандартный и надёжный механизм безопасности",
            "Да, но только в браузере Chrome последних версий",
            "Только для защиты статических файлов и изображений",
            "Да, если используется HTTPS вместо HTTP",
            "Нет, но только на мобильных устройствах",
            "Да, если дополнительно проверять User-Agent"
        ],
        correctAnswerIndex: 0,
        explanation: "Referer легко подделать или он может отсутствовать (настройки приватности, HTTPS→HTTP). Никогда не используйте его как единственную меру защиты.",
        link: {
            label: "MDN: Referer Header",
            url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referer"
        }
    },
    {
        question: "Почему важно инвалидировать сессии после смены прав пользователя?",
        answers: [
            "Чтобы пользователь не мог использовать старую сессию с правами, которые у него уже отобрали",
            "Для освобождения оперативной памяти на сервере",
            "Для сбора статистики активности пользователей",
            "Чтобы пользователь заново ввёл пароль для тренировки памяти",
            "Для улучшения производительности базы данных",
            "Чтобы обновить cookies в браузере пользователя",
            "Для соответствия требованиям GDPR"
        ],
        correctAnswerIndex: 0,
        explanation: "Если у пользователя отобрали роль admin, но сессия осталась активной с claim role=admin, он продолжит иметь доступ. Нужно принудительно разлогинить или обновить токен.",
        link: {
            label: "OWASP: Session Management",
            url: "https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html"
        }
    },
    {
        question: "Как находить уязвимости контроля доступа в микросервисной архитектуре?",
        answers: [
            "Проверять каждый микросервис отдельно и взаимодействие между ними, так как права могут не синхронизироваться",
            "Проверить только API Gateway, так как он контролирует весь доступ",
            "В микросервисах уязвимостей контроля доступа не бывает",
            "Отключить все микросервисы кроме основного",
            "Проверять только сервисы, написанные на Java",
            "Использовать только автоматические сканеры",
            "Проверять только публичные эндпоинты"
        ],
        correctAnswerIndex: 0,
        explanation: "В микросервисах проверка может быть на Gateway, но сервисы также должны её выполнять. Часто сервисы доверяют друг другу, что опасно (принцип Zero Trust).",
        link: {
            label: "OWASP: Microservices Security",
            url: "https://owasp.org/www-project-microservices-top-10/"
        }
    },
    {
        question: "Что такое Mass Assignment (Auto-Binding) уязвимость?",
        answers: [
            "Автоматическое связывание параметров запроса с полями модели, позволяющее изменить защищённые поля (isAdmin=true)",
            "Массовая регистрация пользователей ботами",
            "Автоматическое нагрузочное тестирование приложения",
            "Связывание внешних ключей таблиц в базе данных",
            "Массовая рассылка email-уведомлений пользователям",
            "Автоматическое назначение ролей новым пользователям",
            "Групповое обновление записей в базе данных"
        ],
        correctAnswerIndex: 0,
        explanation: "Если фреимворк автоматически биндит все параметры запроса к модели, атакующий может добавить isAdmin=true или role=admin в запрос и изменить защищённые поля. Используйте whitelist полей!",
        link: {
            label: "OWASP: Mass Assignment",
            url: "https://cheatsheetseries.owasp.org/cheatsheets/Mass_Assignment_Cheat_Sheet.html"
        }
    },
    {
        question: "Какой инструмент помогает быстро перебирать ID для поиска IDOR?",
        answers: [
            "Burp Intruder или Turbo Intruder — для быстрого перебора последовательных ID",
            "Wireshark — для анализа сетевого трафика",
            "Nmap — для сканирования открытых портов",
            "Metasploit — для эксплуатации уязвимостей",
            "SQLMap — для тестирования SQL инъекций",
            "OWASP ZAP Spider — для сканирования структуры сайта",
            "Nikto — для поиска известных уязвимостей веб-сервера"
        ],
        correctAnswerIndex: 0,
        explanation: "Turbo Intruder (расширение Burp) позволяет очень быстро отправлять тысячи запросов с разными ID. Intruder в Burp Suite (бесплатная версия медленная) также подходит.",
        link: {
            label: "Turbo Intruder",
            url: "https://github.com/PortSwigger/turbo-intruder"
        }
    },
    {
        question: "Если вы нашли файл backup.sql в корне сайта, это какая категория уязвимости?",
        answers: [
            "Sensitive Data Exposure и Broken Access Control — доступ к конфиденциальным файлам без авторизации",
            "XSS — межсайтовое выполнение скриптов",
            "SQL Injection — внедрение SQL-кода",
            "CSRF — подделка межсайтовых запросов",
            "Command Injection — выполнение системных команд",
            "SSRF — подделка запросов на стороне сервера",
            "XXE — внедрение внешних XML-сущностей"
        ],
        correctAnswerIndex: 0,
        explanation: "Доступ к .sql/.bak/.old файлам — это Broken Access Control (нет защиты файлов) + Information Disclosure. Эти файлы могут содержать пароли, исходный код, структуру БД.",
        link: {
            label: "OWASP: Sensitive Data Exposure",
            url: "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
        }
    },
    {
        question: "Является ли доступ к /admin через IP-адрес (обход проверки домена) уязвимостью?",
        answers: [
            "Да, это обход контроля доступа через Host Header Attack или прямой доступ по IP",
            "Нет, это нормальная функциональность веб-сервера",
            "Только если IP-адрес публичный, а не приватный",
            "Нет, администраторы всегда ходят по IP-адресу",
            "Да, но только если используется HTTP вместо HTTPS",
            "Нет, это особенность настройки DNS-сервера",
            "Только если IP-адрес принадлежит к диапазону IPv6"
        ],
        correctAnswerIndex: 0,
        explanation: "Если доступ ограничен по домену (admin.example.com), но не по IP, атакующий может обойти это, подключившись напрямую к IP. Используйте IP whitelist или аутентификацию.",
        link: {
            label: "PortSwigger: Host Header Attacks",
            url: "https://portswigger.net/web-security/host-header"
        }
    },
    {
        question: "Нужно ли защищать контролем доступа картинки и PDF-документы?",
        answers: [
            "Да, если они содержат конфиденциальную информацию (паспорта, медкарты, финансовые отчёты)",
            "Нет, это просто статические файлы без личных данных",
            "Только если размер файла превышает 1 МБ",
            "Нет, браузер автоматически защитит их Same-Origin Policy",
            "Только если файлы имеют расширение .exe или .dll",
            "Нет, защита нужна только для HTML-страниц",
            "Да, но только для картинок формата PNG и SVG"
        ],
        correctAnswerIndex: 0,
        explanation: "Личные документы (договоры, паспорта, счета) нельзя просто класть в /public. Раздавайте через контроллер с проверкой прав или используйте pre-signed URLs (S3).",
        link: {
            label: "AWS: Pre-signed URLs",
            url: "https://docs.aws.amazon.com/AmazonS3/latest/userguide/PresignedUrlUploadObject.html"
        }
    },
    {
        question: "Чем опасен публичный доступ к директории .git?",
        answers: [
            "Можно скачать весь исходный код проекта и историю коммитов с помощью GitTools или wget",
            "Ничем, это просто система контроля версий для разработки",
            "Можно напрямую изменить код на продакшн-сервере",
            "Это только увеличивает размер веб-сайта на диске",
            "Можно украсть учётные данные Git-пользователей",
            "Это приводит к замедлению работы веб-сервера",
            "Можно получить доступ к панели администратора Git"
        ],
        correctAnswerIndex: 0,
        explanation: "Если .git доступна, атакующий может восстановить весь репозиторий (git-dumper, GitTools). Там могут быть пароли, ключи API, вся логика приложения. Блокируйте .git в nginx/apache!",
        link: {
            label: "GitTools",
            url: "https://github.com/internetwache/GitTools"
        }
    },
    {
        question: "Как проверить уязвимость GraphQL к Broken Access Control?",
        answers: [
            "Попробовать запросить поля или выполнить мутации, недоступные текущей роли пользователя",
            "GraphQL по определению не уязвим к проблемам контроля доступа",
            "Проверить наличие SQL-инъекций в GraphQL-запросах",
            "Полностью отключить функцию интроспекции (introspection)",
            "Использовать только GET-запросы вместо POST",
            "Проверить версию используемой библиотеки GraphQL",
            "Отключить все мутации и оставить только queries"
        ],
        correctAnswerIndex: 0,
        explanation: "GraphQL часто забывают защитить на уровне resolver'ов. Попробуйте запросить user{email} или выполнить deleteUser от имени обычного пользователя. Каждый resolver должен проверять права!",
        link: {
            label: "OWASP: GraphQL Cheat Sheet",
            url: "https://cheatsheetseries.owasp.org/cheatsheets/GraphQL_Cheat_Sheet.html"
        }
    },
    {
        question: "Что такое ABAC (Attribute-Based Access Control)?",
        answers: [
            "Контроль доступа на основе атрибутов пользователя, ресурса и окружения (время, IP, отдел)",
            "Контроль доступа на основе алфавитного порядка пользователей",
            "Автоматическое создание резервных копий системы контроля доступа",
            "Упрощённая версия RBAC только с двумя ролями",
            "Контроль доступа только для мобильных приложений",
            "Система доступа на основе количества посещений",
            "Аутентификация через биометрические данные"
        ],
        correctAnswerIndex: 0,
        explanation: "ABAC более гибкая, чем RBAC. Пример: 'Разрешить редактировать документ, если пользователь из отдела Legal И документ со статусом=draft И время 9-18'. Используется в сложных enterprise-системах.",
        link: {
            label: "NIST: ABAC",
            url: "https://nvlpubs.nist.gov/nistpubs/specialpublications/NIST.sp.800-162.pdf"
        }
    },
    {
        question: "Если API возвращает данные другого пользователя в JSON, но фронтенд их не показывает, это уязвимость?",
        answers: [
            "Да, это Data Leakage и IDOR — данные не должны попадать в ответ API вообще",
            "Нет, это безопасно, так как пользователь их не видит в UI",
            "Это просто ошибка вёрстки, не затрагивающая безопасность",
            "Нет, это нормальная оптимизация для кэширования данных",
            "Только если данные содержат пароли пользователей",
            "Нет, JSON автоматически шифруется браузером",
            "Только если используется HTTP вместо HTTPS"
        ],
        correctAnswerIndex: 0,
        explanation: "Если API отдаёт { users: [{id:1, email:'alice@...'}, {id:2, email:'bob@...'}] }, и JS фильтрует только текущего пользователя — это уязвимость. Атакующий увидит данные в DevTools/Burp.",
        link: {
            label: "OWASP API Security: BOLA",
            url: "https://owasp.org/API-Security/editions/2023/en/0xa1-broken-object-level-authorization/"
        }
    },
    {
        question: "Можно ли использовать HTTP-методы как единственную меру защиты?",
        answers: [
            "Нет, недостаточно — нужна проверка прав внутри обработчика, так как метод легко изменить",
            "Да, если разрешить только безопасный метод GET",
            "Да, это полная и надёжная защита от всех атак",
            "Нет, методы HTTP вообще не влияют на безопасность",
            "Только для RESTful API с правильным дизайном",
            "Да, если дополнительно использовать OPTIONS preflight",
            "Только для статических одностраничных сайтов"
        ],
        correctAnswerIndex: 0,
        explanation: "Ограничение по методу (только POST) можно обойти, просто изменив метод на PUT или PATCH. Метод — это часть дизайна API, но не мера безопасности. Проверяйте права в коде!",
        link: {
            label: "PortSwigger: Method Override",
            url: "https://portswigger.net/web-security/access-control/lab-method-based-access-control-can-be-circumvented"
        }
    },
    {
        question: "Что такое Insecure Direct Object Reference простыми словами?",
        answers: [
            "Прямая ссылка на объект (файл, запись в БД) без проверки, имеет ли пользователь право на доступ к нему",
            "Ссылка, которая слишком сложная и длинная для пользователя",
            "Внешняя ссылка на другой веб-сайт или домен",
            "Неработающая или битая ссылка (404 Not Found)",
            "Ссылка без использования протокола HTTPS",
            "Относительная ссылка вместо абсолютной в HTML",
            "Ссылка с параметрами в query string"
        ],
        correctAnswerIndex: 0,
        explanation: "IDOR — это GET /invoice/123, где сервер просто берёт ID из URL и отдаёт документ, не проверяя, принадлежит ли invoice #123 текущему пользователю.",
        link: {
            label: "PortSwigger: IDOR",
            url: "https://portswigger.net/web-security/access-control/idor"
        }
    },
    {
        question: "Какие данные чаще всего являются целью атак на контроль доступа?",
        answers: [
            "PII (персональные данные), финансовая информация, функции администрирования и управления",
            "Файлы CSS-стилей и JavaScript-библиотеки",
            "Публичные новостные статьи и пресс-релизы компании",
            "Текст лицензионного соглашения и политики конфиденциальности",
            "Изображения логотипов и иконок интерфейса",
            "Шрифты и файлы локализации интерфейса",
            "Открытый исходный код компонентов UI"
        ],
        correctAnswerIndex: 0,
        explanation: "Атакующие ищут: личные данные (имена, email, телефоны), платёжную информацию, медицинские записи, админ-панели, возможность изменять/удалять данные других пользователей.",
        link: {
            label: "OWASP: Sensitive Data",
            url: "https://owasp.org/www-community/vulnerabilities/Information_exposure_through_query_strings_in_url"
        }
    },
    {
        question: "Помогает ли WAF (Web Application Firewall) от всех видов Broken Access Control?",
        answers: [
            "Нет, WAF не понимает бизнес-логику и контекст прав конкретного пользователя",
            "Да, WAF блокирует все атаки на контроль доступа автоматически",
            "Только если WAF платный и enterprise-уровня",
            "Да, если корректно настроены правила для SQLi и XSS",
            "WAF защищает только от DDoS-атак, а не от BAC",
            "Да, но только для приложений на PHP и Python",
            "Только если WAF установлен на уровне облачного провайдера"
        ],
        correctAnswerIndex: 0,
        explanation: "WAF может блокировать простые атаки, но не понимает, что 'user123 может редактировать только свои заказы'. Бизнес-логику и проверку прав нужно реализовывать в приложении.",
        link: {
            label: "OWASP: WAF Limitations",
            url: "https://owasp.org/www-community/Web_Application_Firewall"
        }
    },
    {
        question: "Что делать, если фреймворк не имеет встроенной защиты от BAC?",
        answers: [
            "Реализовать middleware, декораторы или interceptors для централизованной проверки прав перед каждым действием",
            "Немедленно сменить фреймворк на более безопасный",
            "Оставить как есть и надеяться на лучшее",
            "Написать собственный фреймворк с нуля",
            "Использовать только автоматические сканеры безопасности",
            "Отключить все функции, требующие авторизации",
            "Перейти на микросервисную архитектуру"
        ],
        correctAnswerIndex: 0,
        explanation: "Большинство фреймворков не предоставляют готовое решение для авторизации. Нужно создать middleware/guards/policies, которые будут проверять права перед выполнением action/route.",
        link: {
            label: "OWASP: Authorization Patterns",
            url: "https://cheatsheetseries.owasp.org/cheatsheets/Authorization_Cheat_Sheet.html"
        }
    },
    {
        question: "Является ли CSRF разновидностью Broken Access Control?",
        answers: [
            "Технически связаны, но это разные категории OWASP — CSRF заставляет выполнить действие, BAC — напрямую обходит проверку прав",
            "Да, CSRF и BAC — это абсолютно одно и то же",
            "Нет никакой связи, это полностью разные уязвимости",
            "CSRF — это всего лишь подвид XSS-атак",
            "Да, CSRF устарел и больше не актуален в 2024+",
            "CSRF относится только к мобильным приложениям",
            "CSRF — это проблема только для форм с методом GET"
        ],
        correctAnswerIndex: 0,
        explanation: "CSRF отличается: атакующий не получает доступ напрямую, а заставляет жертву выполнить действие. Но обе уязвимости про несанкционированные действия. SameSite cookies помогают от CSRF.",
        link: {
            label: "PortSwigger: CSRF vs BAC",
            url: "https://portswigger.net/web-security/csrf"
        }
    },
    {
        question: "Как атакующий может использовать функцию 'Восстановление пароля' для BAC?",
        answers: [
            "Подменить ID или email в запросе на сброс пароля, чтобы получить ссылку на сброс для чужой учётной записи",
            "Это невозможно, функция восстановления всегда безопасна",
            "Отправить множество запросов для DoS-атаки",
            "Изменить тему и текст письма с инструкциями",
            "Перехватить email через Man-in-the-Middle атаку",
            "Использовать брутфорс для подбора кода восстановления",
            "Изменить дизайн страницы восстановления пароля"
        ],
        correctAnswerIndex: 0,
        explanation: "Если форма восстановления принимает параметр email или user_id, атакующий может подставить чужой email и получить токен сброса. Сервер должен проверять, что запрос идёт для текущей сессии.",
        link: {
            label: "OWASP: Forgot Password",
            url: "https://cheatsheetseries.owasp.org/cheatsheets/Forgot_Password_Cheat_Sheet.html"
        }
    },
    {
        question: "Что такое Race Condition в контексте контроля доступа?",
        answers: [
            "Состояние гонки, когда из-за параллельных запросов можно обойти проверку (например, применить промокод дважды)",
            "Соревнование хакеров кто быстрее взломает систему",
            "Оптимизация скорости загрузки веб-сайта",
            "Конкурс на лучшую скорость ввода пароля",
            "Автоматическая гонка обновлений безопасности",
            "Проблема с таймаутом сессии пользователя",
            "Конфликт версий в системе контроля версий"
        ],
        correctAnswerIndex: 0,
        explanation: "Race Condition: 2 запроса 'использовать купон' отправлены одновременно. Оба прошли проверку 'купон не использован', и купон применился дважды. Нужны транзакции БД и блокировки!",
        link: {
            label: "PortSwigger: Race Conditions",
            url: "https://portswigger.net/web-security/race-conditions"
        }
    },
    {
        question: "Почему GET-запросы не должны изменять состояние на сервере?",
        answers: [
            "GET может кешироваться, добавляться в закладки, вызываться prefetch-ом браузера и уязвим к CSRF без токена",
            "GET-запросы работают медленнее POST-запросов",
            "POST-запросы выглядят красивее в логах",
            "Это обязательное требование стандарта HTML5",
            "GET может передать меньше данных, чем POST",
            "POST-запросы лучше защищены браузером",
            "GET запросы не поддерживают CORS"
        ],
        correctAnswerIndex: 0,
        explanation: "GET должен быть idempotent (безопасный). Если DELETE /user/123 доступен через GET, атакующий может вставить <img src='https://site.com/delete/user/123'> и пользователь удалится при открытии страницы!",
        link: {
            label: "MDN: HTTP Methods",
            url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods"
        }
    },
    {
        question: "Как тестировать контроль доступа в мобильных приложениях?",
        answers: [
            "Перехватывать API-запросы через прокси (Burp/Charles) и проверять права на серверной стороне",
            "Просто просматривать интерфейс приложения и проверять видимость кнопок",
            "Мобильные приложения защищены Store и не требуют тестирования",
            "Декомпилировать APK и читать исходный код Java",
            "Использовать только автоматические Mobile Security Scanners",
            "Проверять только iOS-приложения, Android защищён песочницей",
            "Тестировать приложения только на эмуляторах, не на реальных устройствах"
        ],
        correctAnswerIndex: 0,
        explanation: "Мобильное приложение — это просто клиент. Вся логика и защита должна быть на API. Перехватывайте запросы (Burp + настройка прокси на устройстве) и тестируйте как обычное API.",
        link: {
            label: "OWASP Mobile Top 10",
            url: "https://owasp.org/www-project-mobile-top-10/"
        }
    },
    {
        question: "Что такое BOLA (Broken Object Level Authorization)?",
        answers: [
            "Современное название для IDOR в контексте API — отсутствие проверки прав доступа к объектам",
            "Болезньваемость базы данных к SQL-инъекциям",
            "Ошибка балансировки нагрузки между серверами",
            "Broken Online Login Authentication — проблема аутентификации",
            "Binary Object Level Access — доступ к бинарным файлам",
            "Backend Offline Latency Alert — предупреждение о задержке",
            "Business Object Lifecycle Automation — автоматизация жизненного цикла"
        ],
        correctAnswerIndex: 0,
        explanation: "BOLA — это термин из OWASP API Security Top 10. По сути, это IDOR для API: GET /api/users/456 возвращает данные без проверки прав. Это №1 в API Security Top 10!",
        link: {
            label: "OWASP API Security: BOLA",
            url: "https://owasp.org/API-Security/editions/2023/en/0xa1-broken-object-level-authorization/"
        }
    },
    {
        question: "Нужно ли логировать попытки несанкционированного доступа?",
        answers: [
            "Да, это помогает обнаружить атаки, расследовать инциденты и соответствовать требованиям compliance",
            "Нет, логи только занимают дискове пространство",
            "Только если это требование законодательства конкретной страны",
            "Нет, логирование снижает производительность приложения",
            "Только для приложений с платёжными данными",
            "Да, но только для Windows-серверов, не для Linux",
            "Нет, это нарушает конфиденциальность пользователей"
        ],
        correctAnswerIndex: 0,
        explanation: "Логи попыток доступа к чужим ресурсам помогают: обнаружить атаки в реальном времени (SIEM), расследовать инциденты post-factum, соответствовать PCI DSS, GDPR и другим стандартам.",
        link: {
            label: "OWASP: Logging Cheat Sheet",
            url: "https://cheatsheetseries.owasp.org/cheatsheets/Logging_Cheat_Sheet.html"
        }
    },
    {
        question: "Что означает термин 'Context-dependent access control'?",
        answers: [
            "Права доступа зависят от контекста: времени, геолокации, состояния объекта, роли и других факторов",
            "Доступ зависит только от типа контента (JSON, XML, HTML)",
            "Права доступа определяются размером запрошенного файла",
            "Контроль доступа только для контекстной рекламы",
            "Доступ зависит от операционной системы пользователя",
            "Проверка прав только в контексте базы данных",
            "Доступ определяется языком интерфейса (ru, en)"
        ],
        correctAnswerIndex: 0,
        explanation: "Пример: 'Пользователь может редактировать документ, если он автор ИЛИ (роль=editor И документ не в статусе published)'. Контекст: роль, владение, статус, время.",
        link: {
            label: "OWASP: Context-Based Authorization",
            url: "https://cheatsheetseries.owasp.org/cheatsheets/Authorization_Cheat_Sheet.html"
        }
    },
    {
        question: "Может ли функция экспорта данных быть источником BAC-уязвимости?",
        answers: [
            "Да, если не проверяются права на экспортируемые данные (например, экспорт всех пользователей вместо только своих)",
            "Нет, экспорт — это всегда безопасная операция чтения",
            "Только если экспорт происходит в формате CSV",
            "Нет, форматы XLS и PDF автоматически защищены",
            "Только для экспорта в облачные хранилища",
            "Нет, кнопка экспорта всегда требует admin-прав",
            "Только при экспорте больше 1000 записей"
        ],
        correctAnswerIndex: 0,
        explanation: "Экспорт часто забывают защитить. Пользователь видит 10 записей на странице (свои), но GET /export.csv без фильтрации выгружает ВСЕ записи БД. Применяйте те же фильтры прав!",
        link: {
            label: "OWASP: Data Exfiltration",
            url: "https://owasp.org/www-community/attacks/Data_Manipulation"
        }
    },
    {
        question: "Как проверить уязвимость в функции смены email?",
        answers: [
            "Попробовать изменить email другого пользователя, подставив чужой user_id или токен в запросе",
            "Просто попробовать сменить свой email на корректный",
            "Проверить наличие подтверждения по старому email",
            "Попытаться использовать email с XSS-полезной нагрузкой",
            "Проверить длину допустимого email-адреса",
            "Попробовать сменить email на несуществующий домен",
            "Использовать brute-force для подбора email-адресов"
        ],
        correctAnswerIndex: 0,
        explanation: "POST /api/users/changeEmail с параметрами {userId: 456, newEmail: 'hacker@...'} — если сервер не проверит, что userId=456 это текущий пользователь, email сменится у жертвы.",
        link: {
            label: "OWASP: Account Management",
            url: "https://cheatsheetseries.owasp.org/cheatsheets/Forgot_Password_Cheat_Sheet.html"
        }
    },
    {
        question: "Что такое Business Logic Flaw с точки зрения контроля доступа?",
        answers: [
            "Ошибка в бизнес-логике, позволяющая обойти проверки через нестандартную последовательность действий",
            "Ошибка в логике работы SQL-запросов к базе данных",
            "Недостаток производительности из-за плохого алгоритма",
            "Ошибка в дизайне пользовательского интерфейса",
            "Проблема с кэшированием бизнес-правил",
            "Отсутствие документации бизнес-процессов",
            "Конфликт версий библиотек бизнес-логики"
        ],
        correctAnswerIndex: 0,
        explanation: "Пример: оформить заказ → применить промокод (-50%) → отменить заказ → вернуться назад (по back в браузере) → оформить снова с тем же кодом. Технически каждый шаг разрешён, но последовательность обходит ограничение.",
        link: {
            label: "PortSwigger: Business Logic Vulnerabilities",
            url: "https://portswigger.net/web-security/logic-flaws"
        }
    },
    {
        question: "Нужно ли защищать API-эндпоинты, используемые только внутренним фронтендом?",
        answers: [
            "Да обязательно, так как атакующий может найти и использовать эти эндпоинты напрямую",
            "Нет, если они не задокументированы в Swagger",
            "Нет, внутренние эндпоинты по определению безопасны",
            "Только если фронтенд — это SPA на React/Vue",
            "Нет, достаточно защиты на уровне CORS",
            "Только эндпоинты для мобильных приложений",
            "Нет, если используется Content-Security-Policy"
        ],
        correctAnswerIndex: 0,
        explanation: "Нет понятия 'внутренний эндпоинт' для API. Атакующий может: смотреть Network в DevTools, декомпилировать минифицированный JS, использовать Burp. Защищайте ВСЕ эндпоинты!",
        link: {
            label: "OWASP API Security",
            url: "https://owasp.org/www-project-api-security/"
        }
    },
    {
        question: "Что такое Privilege Creep?",
        answers: [
            "Накопление избыточных прав у пользователя со временем (сменил должность, но права от старой остались)",
            "Медленное повышение привилегий через SQL Injection",
            "Автоматическое повышение прав после длительного использования",
            "Постепенное снижение производительности из-за роста привилегий",
            "Утечка привилегий через cookies в браузере",
            "Миграция привилегий между микросервисами",
            "Дублирование прав в разных таблицах БД"
        ],
        correctAnswerIndex: 0,
        explanation: "Privilege Creep: сотрудник работал в отделе А (получил права), перешёл в отдел Б (добавили права), повысили (ещё права). Итог — избыточные права. Нужен регулярный audit и отзыв (revocation).",
        link: {
            label: "Principle of Least Privilege",
            url: "https://en.wikipedia.org/wiki/Principle_of_least_privilege"
        }
    },
    {
        question: "Почему важно тестировать права доступа и для успешных, и для неуспешных сценариев?",
        answers: [
            "Чтобы убедиться, что запрещённые действия блокируются (403), а разрешённые — выполняются (200)",
            "Успешные сценарии тестировать не нужно, только ошибки",
            "Неуспешные сценарии не влияют на безопасность приложения",
            "Это нужно только для юнит-тестирования, не для security",
            "Чтобы проверить производительность при разных статус-кодах",
            "Только успешные сценарии важны для UX",
            "Это требование только для тестирования UI"
        ],
        correctAnswerIndex: 0,
        explanation: "Позитивное тестирование: admin может удалить пользователя (200 OK). Негативное: обычный user НЕ может удалить (403 Forbidden). Оба важны — иначе можете пропустить missing authorization check.",
        link: {
            label: "OWASP Testing Guide: Authorization",
            url: "https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/05-Authorization_Testing/README"
        }
    },
    {
        question: "Может ли OAuth 2.0 помочь от Broken Access Control?",
        answers: [
            "OAuth решает аутентификацию и делегирование прав, но авторизацию каждого действия приложение реализует сам",
            "Да, OAuth полностью решает все проблемы контроля доступа",
            "Нет, OAuth только для социальных сетей (Facebook Login)",
            "OAuth заменяет необходимость в RBAC и ABAC",
            "Только если используется OAuth 2.1 вместо 2.0",
            "OAuth защищает только мобильные приложения",
            "Нет, OAuth — это протокол только для шифрования"
        ],
        correctAnswerIndex: 0,
        explanation: "OAuth даёт токен доступа (access_token) и может определить scopes (read, write). Но проверять 'может ли user123 редактировать order456' должно приложение согласно своей бизнес-логике.",
        link: {
            label: "OAuth 2.0 Security",
            url: "https://oauth.net/2/"
        }
    },
    {
        question: "Как тестировать контроль доступа в multi-tenant приложениях (SaaS)?",
        answers: [
            "Создать несколько тестовых аккаунтов в разных tenant'ах и проверить изоляцию данных между ними",
            "Multi-tenant приложения защищены по определению архитектуры",
            "Достаточно тестирования одного tenant'а",
            "Это проблема только для on-premise решений",
            "Проверять только разделение на уровне базы данных",
            "Тестировать только функции администратора",
            "Это решается на уровне облачного провайдера"
        ],
        correctAnswerIndex: 0,
        explanation: "Multi-tenancy: организация А и организация Б используют одно приложение. КРИТИЧНО проверить, что user из А не может получить данные организации Б (tenant_id в каждом запросе!)",
        link: {
            label: "OWASP: Multi-Tenancy",
            url: "https://cheatsheetseries.owasp.org/cheatsheets/Multitenant_Architecture_Cheat_Sheet.html"
        }
    },
    {
        question: "Что делать, если на проекте нет автоматических тестов контроля доступа?",
        answers: [
            "Написать хотя бы базовые Authz-тесты для критичных функций (удаление, изменение чужих данных)",
            "Полагаться только на ручное тестирование каждый раз",
            "Это нормально, авто-тесты не нужны для security",
            "Использовать только коммерческие DAST-сканеры",
            "Ничего не делать, если нет выделенных QA",
            "Перенести тестирование полностью на penetration testing",
            "Документировать проблему и оставить как есть"
        ],
        correctAnswerIndex: 0,
        explanation: "Автотесты — это regression protection. Напишите тесты: 'user не может DELETE /api/users/:id чужого пользователя (ожидаем 403)'. Это предотвратит случайное удаление проверки в будущем.",
        link: {
            label: "OWASP: Security Unit Testing",
            url: "https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/05-Authorization_Testing/README"
        }
    },
    {
        question: "Что такое Token Sidejacking в контексте BAC?",
        answers: [
            "Кража токена или сессии пользователя для получения его прав доступа (через XSS, MitM, физический доступ)",
            "Боковая атака на механизм генерации токенов",
            "Перехват токенов только в публичных Wi-Fi сетях",
            "Подбор токенов методом брутфорса",
            "Изменение значения токена в cookies через DevTools",
            "Использование токена после его истечения (expiration)",
            "Автоматическая ротация токенов каждые 5 минут"
        ],
        correctAnswerIndex: 0,
        explanation: "Session Hijacking/Sidejacking: атакующий крадёт session_id или JWT через XSS, сниффинг незашифрованного трафика, физический доступ к компьютеру. Затем использует токен для доступа к аккаунту жертвы.",
        link: {
            label: "OWASP: Session Hijacking",
            url: "https://owasp.org/www-community/attacks/Session_hijacking_attack"
        }
    },
    {
        question: "Помогает ли rate limiting (ограничение частоты запросов) от BAC?",
        answers: [
            "Частично — замедляет массовый перебор ID (IDOR enumeration), но не заменяет проверку прав",
            "Да, полностью решает все проблемы контроля доступа",
            "Нет, rate limiting влияет только на DDoS-атаки",
            "Только для API, не для веб-приложений",
            "Rate limiting нужен только для функций аутентификации",
            "Нет никакой связи между rate limiting и BAC",
            "Только если используется Redis для хранения счётчиков"
        ],
        correctAnswerIndex: 0,
        explanation: "Rate limiting замедляет автоматический перебор /api/invoices/1, /api/invoices/2... но не предотвращает однократный доступ к /api/invoices/999 (чужой). Нужны ОБЕ защиты.",
        link: {
            label: "OWASP: Rate Limiting",
            url: "https://cheatsheetseries.owasp.org/cheatsheets/Denial_of_Service_Cheat_Sheet.html"
        }
    },
    {
        question: "Что такое Function Level Authorization (OWASP API)?",
        answers: [
            "Проверка, имеет ли пользователь право вызвать конкретную функцию/метод API (например, deleteUser)",
            "Авторизация на уровне вызова JavaScript-функций в браузере",
            "Проверка прав доступа к Lambda-функциям в AWS",
            "Контроль доступа к SQL-функциям и процедурам",
            "Авторизация вызовов функций в IoT-устройствах",
            "Проверка прав на использование встроенных функций языка программирования",
            "Уровень доступа для serverless-функций"
        ],
        correctAnswerIndex: 0,
        explanation: "Function-Level Authorization: обычный user вызывает POST /api/admin/deleteAllUsers. Если сервер не проверит роль перед выполнением функции — это уязвимость. №5 в OWASP API Top 10.",
        link: {
            label: "OWASP API: Function Level Authorization",
            url: "https://owasp.org/API-Security/editions/2023/en/0xa5-broken-function-level-authorization/"
        }
    },
    {
        question: "Нужно ли защищать API-методы OPTIONS (preflight CORS)?",
        answers: [
            "OPTIONS обычно не требует аутентификации, но не должен раскрывать чувствительную информацию о доступных эндпоинтах",
            "Да, OPTIONS должен требовать те же права, что и GET/POST",
            "Нет, OPTIONS — это служебный метод, его защищать не нужно",
            "Только если используется Origin из blacklist",
            "OPTIONS автоматически защищён браузером",
            "Да, нужно требовать JWT-токен для preflight",
            "Только для GraphQL эндпоинтов"
        ],
        correctAnswerIndex: 0,
        explanation: "OPTIONS preflight не требует credentials (иначе CORS сломается). Но ответ не должен раскрывать избыточно детали (например, список всех методов и headers для админских эндпоинтов).",
        link: {
            label: "MDN: CORS Preflight",
            url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#preflight_requests_and_credentials"
        }
    },
    {
        question: "Как prevent атаки Broken Access Control на уровне кода?",
        answers: [
            "Централизованная проверка прав в middleware/guards, явные ACL, тесты, code review и принцип Fail Secure",
            "Использовать только коммерческие WAF-решения",
            "Полагаться на автоматические сканеры безопасности",
            "Запретить разработчикам коммитить код без одобрения security-команды",
            "Использовать только проверенные open-source библиотеки",
            "Шифровать весь код приложения",
            "Переписать приложение на безопасном языке программирования"
        ],
        correctAnswerIndex: 0,
        explanation: "Лучшие практики на уровне кода: middleware для проверки прав, explicit ACL (if !user.canEdit(doc) return 403), юнит-тесты на права, code review с фокусом на Authz, fail secure (deny by default).",
        link: {
            label: "OWASP: Secure Coding Practices",
            url: "https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/"
        }
    },
    {
        question: "Что такое Horizontal to Vertical Privilege Escalation?",
        answers: [
            "Комбинация атак: сначала доступ к данным другого user (горизонтальная), затем повышение до admin (вертикальная)",
            "Переход от вертикальной архитектуры к горизонтальной",
            "Изменение направления атаки с фронтенда на бэкенд",
            "Повышение прав только среди администраторов разных уровней",
            "Автоматическое повышение прав через Race Condition",
            "Технический термин из архитектуры микросервисов",
            "Переход от UI-атак к API-атакам"
        ],
        correctAnswerIndex: 0,
        explanation: "Пример: атакующий получает доступ к профилю другого пользователя (horizontal). В профиле находит API-ключ администратора. Использует ключ для получения admin-прав (vertical). Цепочка атак!",
        link: {
            label: "PortSwigger: Privilege Escalation",
            url: "https://portswigger.net/web-security/access-control"
        }
    },
    {
        question: "Нужно ли проверять права при рендеринге server-side страниц (SSR)?",
        answers: [
            "Да обязательно, так же как и для API — контроллер должен проверить права перед рендерингом данных",
            "Нет, SSR автоматически безопасен благодаря серверной обработке",
            "Только если используется шаблонизатор типа Jinja или EJS",
            "Нет, достаточно проверки на уровне маршрутизатора",
            "Только для динамических блоков, статические проверять не нужно",
            "SSR уязвим только к XSS, не к BAC",
            "Только если страница кэшируется CDN"
        ],
        correctAnswerIndex: 0,
        explanation: "SSR (Next.js, Rails, Django): контроллер получает запрос, делает query к БД, рендерит HTML. Проверка прав нужна ДО query: if !currentUser.canView(document) return 403. Иначе данные попадут в HTML.",
        link: {
            label: "OWASP: Server-Side Access Control",
            url: "https://cheatsheetseries.owasp.org/cheatsheets/Authorization_Cheat_Sheet.html"
        }
    },
    {
        question: "Как влияет REST vs GraphQL на подход к тестированию контроля доступа?",
        answers: [
            "В REST тестируем каждый эндпоинт, в GraphQL — каждый resolver и возможные комбинации запросов полей",
            "GraphQL автоматически безопаснее благодаря schema",
            "REST не требует тестирования, только GraphQL",
            "Подход одинаковый, разницы нет вообще",
            "GraphQL нельзя протестировать из-за гибкости запросов",
            "Только REST уязвим к BAC, GraphQL защищён",
            "Тестировать нужно только мутации, не queries"
        ],
        correctAnswerIndex: 0,
        explanation: "REST: тестируем GET /users/:id, DELETE /users/:id отдельно. GraphQL: тестируем resolver user(id), mutation deleteUser(id), и сложные запросы типа {users{orders{paymentInfo}}} — каждый уровень вложенности!",
        link: {
            label: "OWASP: GraphQL Security",
            url: "https://cheatsheetseries.owasp.org/cheatsheets/GraphQL_Cheat_Sheet.html"
        }
    },
    {
        question: "Что такое Confused Deputy Problem?",
        answers: [
            "Когда система с высокими привилегиями выполняет действие от имени пользователя без проверки его прав",
            "Путаница в назначении ролей пользователям",
            "Конфликт прав между двумя администраторами",
            "Ошибка делегирования прав между микросервисами",
            "Проблема с производительностью из-за проверки прав",
            "Двойная аутентификация для одного пользователя",
            "Конфликт версий в системе управления правами"
        ],
        correctAnswerIndex: 0,
        explanation: "Confused Deputy: компилятор (высокие права) компилирует код пользователя (низкие права) и по команде из кода пишет в защищённый файл. Компилятор — 'confused deputy', которого обманули выполнить действие.",
        link: {
            label: "Confused Deputy Problem",
            url: "https://en.wikipedia.org/wiki/Confused_deputy_problem"
        }
    },
    {
        question: "Можно ли использовать client-side JavaScript для enforce authorization rules?",
        answers: [
            "Нет, JavaScript легко обойти — он подходит только для улучшения UX, но не для безопасности",
            "Да, если используется современный фреймворк типа React или Vue",
            "Да, если код обфусцирован и минифицирован",
            "Только если используется WebAssembly вместо JS",
            "Да, если проверки вынесены в Web Workers",
            "Только для Progressive Web Apps (PWA)",
            "Да, если используется TypeScript с strict mode"
        ],
        correctAnswerIndex: 0,
        explanation: "Клиентский JS можно отключить, модифицировать, обойти. Используйте его для UX (скрыть кнопку, показать warning), но ВСЕГДА дублируйте проверки на сервере.",
        link: {
            label: "OWASP: Client-Side Security",
            url: "https://cheatsheetseries.owasp.org/cheatsheets/HTML5_Security_Cheat_Sheet.html"
        }
    },
    {
        question: "Как тестировать права доступа при использовании feature flags?",
        answers: [
            "Тестировать комбинации: feature ON/OFF × каждая роль пользователя, проверяя, что доступ корректно управляется",
            "Feature flags не влияют на контроль доступа",
            "Достаточно тестировать только состояние ON",
            "Feature flags — это только для A/B тестов, не для security",
            "Тестировать только в production после релиза",
            "Feature flags автоматически защищены системой",
            "Проверять только один раз при первом включении"
        ],
        correctAnswerIndex: 0,
        explanation: "Feature flags могут случайно открыть доступ: if (featureEnabled('newAdmin') || isAdmin()) {...}. Тестируйте: feature=ON и user=regular должно давать deny; feature=OFF и user=admin тоже может иметь особую логику.",
        link: {
            label: "Feature Flags Best Practices",
            url: "https://martinfowler.com/articles/feature-toggles.html"
        }
    },
    {
        question: "Почему 'Security through Authentication' недостаточно?",
        answers: [
            "Аутентификация только проверяет личность (КТО), но не права (ЧТО может делать) — нужна и авторизация",
            "Аутентификация полностью решает все проблемы безопасности",
            "Это достаточно для внутренних корпоративных приложений",
            "Authentication уже включает в себя authorization",
            "Это устаревший подход, сейчас не используется",
            "Аутентификация нужна только для мобильных приложений",
            "Достаточно, если используется multi-factor authentication"
        ],
        correctAnswerIndex: 0,
        explanation: "Authentication: 'Ты — Bob?'. Authorization: 'Может ли Bob удалить пользователей?'. Часто разработчики проверяют только аутентификацию (if logged_in), забывая авторизацию (if logged_in AND isAdmin).",
        link: {
            label: "Authentication vs Authorization",
            url: "https://auth0.com/docs/get-started/identity-fundamentals/authentication-and-authorization"
        }
    },
    {
        question: "Что означает Zero Trust Architecture в контексте контроля доступа?",
        answers: [
            "Никогда не доверяй, всегда проверяй — каждый запрос должен быть аутентифицирован и авторизован, даже внутри сети",
            "Полное отсутствие доверия к пользователям и блокировка всех действий",
            "Архитектура без использования SSL/TLS сертификатов",
            "Система, где все пользователи имеют нулевые (минимальные) права",
            "Отсутствие системы аутентификации в приложении",
            "Архитектура для блокчейн-приложений без центральной власти",
            "Отказ от использования паролей в пользу биометрии"
        ],
        correctAnswerIndex: 0,
        explanation: "Zero Trust: не доверяем даже внутренним сервисам и запросам внутри корпоративной сети. Каждый запрос аутентифицируется и авторизуется. Это защищает от lateral movement после взлома.",
        link: {
            label: "NIST: Zero Trust Architecture",
            url: "https://www.nist.gov/publications/zero-trust-architecture"
        }
    },
    {
        question: "Как тестировать Broken Access Control автоматически в CI/CD?",
        answers: [
            "Интеграционные тесты с разными ролями пользователей, проверяющие HTTP-статусы (200 vs 403) для критичных эндпоинтов",
            "Автоматическое тестирование невозможно, только ручное penetration testing",
            "Достаточно запустить OWASP ZAP Spider один раз",
            "Использовать только статический анализ кода (SAST)",
            "Полагаться на code coverage метрику > 80%",
            "Проверять только наличие middleware авторизации",
            "Запускать npm audit для проверки зависимостей"
        ],
        correctAnswerIndex: 0,
        explanation: "В CI/CD добавьте интеграционные тесты: 'as admin: DELETE /users/:id → 200', 'as user: DELETE /users/:id → 403'. Это ловит регрессии при изменении кода.",
        link: {
            label: "OWASP: DevSecOps",
            url: "https://owasp.org/www-project-devsecops-guideline/"
        }
    },
    {
        question: " Нужно ли реализовывать audit trail (журнал аудита) для действий пользователей?",
        answers: [
            "Да, особенно для критичных действий (изменение прав, удаление данных) — это помогает расследованию и compliance",
            "Нет, это избыточно и замедляет приложение",
            "Только для финансовых приложений и банков",
            "Нет, логов приложения достаточно",
            "Только если этого требует заказчик явно",
            "Audit trail нужен только для Windows-приложений",
            "Нет, это нарушает GDPR и приватность"
        ],
        correctAnswerIndex: 0,
        explanation: "Audit trail: WHO did WHAT, WHEN, WHERE. Критично для расследования 'кто удалил данные', compliance (SOC 2, ISO 27001), forensics. Логировать: user_id, action, resource_id, timestamp, IP.",
        link: {
            label: "OWASP: Logging Guide",
            url: "https://cheatsheetseries.owasp.org/cheatsheets/Logging_Cheat_Sheet.html"
        }
    },
    {
        question: "Можетли SQL Injection привести к Broken Access Control?",
        answers: [
            "Да, через SQLi можно обойти проверки прав: WHERE user_id=123 AND role='admin' → WHERE user_id=123 OR 1=1",
            "Нет, это разные категории уязвимостей без связи",
            "SQLi влияет только на конфиденциальность данных",
            "Только если используется NoSQL база данных",
            "SQLi устарела и не актуальна с 2020 года",
            "Только в приложениях на PHP, не на Node.js",
            "SQLi относится только к аутентификации, не авторизации"
        ],
        correctAnswerIndex: 0,
        explanation: "SQLi может обойти логику прав: `SELECT * FROM docs WHERE owner_id=${userId} AND isPublic=1` → если userId='1 OR 1=1', получим все документы. SQLi может эскалировать в BAC!",
        link: {
            label: "OWASP: SQL Injection",
            url: "https://owasp.org/www-community/attacks/SQL_Injection"
        }
    },
    {
        question: "Что такое Capability-Based Security?",
        answers: [
            "Модель безопасности, где вместо проверки прав передаются токены-возможности (capabilities), дающие доступ к конкретным ресурсам",
            "Безопасность на основе технических возможностей сервера",
            "Проверка возможностей браузера пользователя (JavaScript, cookies)",
            "Оценка производительности (capacity) системы безопасности",
            "Система безопасности для приложений машинного обучения",
            "Архитектура для распределённых систем с eventual consistency",
            "Безопасность на уровне сетевых capabilities (bandwidth)"
        ],
        correctAnswerIndex: 0,
        explanation: "Capabilities: вместо 'проверить, может ли user123 читать file456', выдаём токен (capability) на чтение file456. У кого есть токен — тот может. Используется в AWS S3 pre-signed URLs.",
        link: {
            label: "Capability-Based Security",
            url: "https://en.wikipedia.org/wiki/Capability-based_security"
        }
    },
    {
        question: "Как проверить уязвимость в batch operations (массовые операции)?",
        answers: [
            "Попробовать включить в список ID чужих объектов: DELETE /api/items {ids: [own_id, victim_id]} и проверить, удалится ли victim_id",
            "Batch operations всегда безопасны, так как обрабатываются транзакцией",
            "Отправить слишком большой список ID для DoS-атаки",
            "Проверка не нужна, если есть rate limiting",
            "Batch operations не поддерживают IDOR по дизайну",
            "Достаточно проверить только первый элемент массива",
            "Это проблема только для NoSQL баз данных"
        ],
        correctAnswerIndex: 0,
        explanation: "Batch API часто проверяют только аутентификацию, но не права на каждый ID: DELETE /api/posts {ids:[1,2,3]}. Сервер должен проверить права для КАЖДОГО id в массиве!",
        link: {
            label: "OWASP API: Bulk Operations",
            url: "https://owasp.org/API-Security/editions/2023/en/0xa1-broken-object-level-authorization/"
        }
    },
    {
        question: "Влияет ли использование ORM (Sequelize, Prisma, TypeORM) на BAC?",
        answers: [
            "ORM помогает от SQLi, но не от BAC — разработчик всё равно должен добавлять фильтры прав в запросы",
            "Да, ORM автоматически решает все проблемы контроля доступа",
            "ORM увеличивает риск BAC из-за абстракций",
            "Только если ORM поддерживает row-level security",
            "ORM безопасен только в режиме strict mode",
            "Влияет негативно, лучше писать сырой SQL",
            "ORM защищает от BAC, но не от SQLi"
        ],
        correctAnswerIndex: 0,
        explanation: "ORM защищает от SQLi через параметризованные запросы, но НЕ добавляет проверки прав. Разработчик должен писать: `where: { id: docId, userId: currentUserId }` — ORM не знает вашу бизнес-логику!",
        link: {
            label: "OWASP: ORM Security",
            url: "https://cheatsheetseries.owasp.org/cheatsheets/Query_Parameterization_Cheat_Sheet.html"
        }
    },
    {
        question: "Что такое Policy-Based Access Control (PBAC)?",
        answers: [
            "Контроль доступа на основе политик (правил), описывающих условия доступа к ресурсам",
            "Контроль доступа на основе политики конфиденциальности",
            "Система безопасности для страховых компаний (policy)",
            "Политический подход к управлению доступом",
            "Контроль доступа только для государственных организаций",
            "Упрощённая версия RBAC с двумя политиками",
            "Система для управления cookies и privacy policies"
        ],
        correctAnswerIndex: 0,
        explanation: "PBAC (часть ABAC): политики описывают правила. Пример: policy 'editors_can_edit_drafts': subject.role='editor' AND resource.status='draft' → allow. Политики централизованны и переиспользуются.",
        link: {
            label: "XACML: Policy-Based Access Control",
            url: "http://docs.oasis-open.org/xacml/3.0/xacml-3.0-core-spec-os-en.html"
        }
    },
    {
        question: "Нужно ли проверять права при использовании WebSockets?",
        answers: [
            "Да обязательно, при установке соединения и при каждом сообщении, так же как для HTTP API",
            "Нет, WebSocket защищён протоколом WS/WSS",
            "Проверка нужна только при handshake, потом нет",
            "WebSocket используется только для публичных данных",
            "Достаточно проверки Origin заголовка",
            "WebSocket автоматически наследует права HTTP-сессии",
            "Проверка нужна только для Socket.IO, не для нативных WebSockets"
        ],
        correctAnswerIndex: 0,
        explanation: "WebSocket: проверяйте права при connection (например, JWT в query string или первом сообщении) и при каждом action. User подключился → проверили токен → каждое msg 'subscribe channel_id' → проверить права на channel!",
        link: {
            label: "OWASP: WebSocket Security",
            url: "https://cheatsheetseries.owasp.org/cheatsheets/WebSocket_Security_Cheat_Sheet.html"
        }
    },
    {
        question: "Что делать, если legacy-код не имеет архитектуры для контроля доступа?",
        answers: [
            "Постепенная рефакторинг: добавить middleware/proxy слой для критичных эндпоинтов, затем расширять покрытие",
            "Полностью переписать приложение с нуля",
            "Отказаться от legacy и мигрировать на SaaS-решение",
            "Оставить как есть, legacy нельзя трогать",
            "Добавить только WAF перед приложением",
            "Документировать проблему и ждать замены системы",
            "Отключить legacy-функционал полностью"
        ],
        correctAnswerIndex: 0,
        explanation: "Strangler Fig Pattern: оборачивайте legacy в новый слой. API Gateway с Authz перед legacy, или reverse-proxy с проверкой прав. Критичные функции рефакторите в первую очередь (admin, финансы).",
        link: {
            label: "Martin Fowler: Strangler Fig",
            url: "https://martinfowler.com/bliki/StranglerFigApplication.html"
        }
    },
    {
        question: "Как влияет caching на контроль доступа?",
        answers: [
            "Кэш может отдать данные пользователю, у которого больше нет прав — нужна инвалидация при смене прав или personalized кэш",
            "Кэширование автоматически улучшает безопасность",
            "Кэш не влияет на контроль доступа никак",
            "Только Redis-кэш уязвим, Memcached безопасен",
            "Кэширование решает проблемы race conditions в авторизации",
            "Кэш подходит только для публичных данных",
            "CDN автоматически учитывает права пользователей"
        ],
        correctAnswerIndex: 0,
        explanation: "Проблема: user был admin, кэш сохранил /api/users (все пользователи), права отобрали, но кэш отдаёт старые данные. Решения: personalized кэш (кэшировать на user_id), короткий TTL, инвалидация при смене роли.",
        link: {
            label: "OWASP: Caching Security",
            url: "https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html"
        }
    },
    {
        question: "Что такое Implicit Grant в OAuth и почему он опасен?",
        answers: [
            "Устаревший OAuth flow, где access_token возвращается в URL (fragment), что упрощает кражу токена через XSS или browser history",
            "Самый безопасный способ получения токенов OAuth",
            "Автоматическое предоставление всех прав приложению",
            "Grant только для мобильных приложений",
            "Метод OAuth для server-to-server взаимодействия",
            "Implicit Grant — это просто legacy название для PKCE",
            "Способ получения refresh_token без password"
        ],
        correctAnswerIndex: 0,
        explanation: "Implicit Grant (deprecated): access_token в URL fragment (http://app.com#access_token=...). XSS может украсть из истории браузера. Используйте Authorization Code + PKCE вместо него!",
        link: {
            label: "OAuth 2.0 Security: Implicit Grant",
            url: "https://oauth.net/2/grant-types/implicit/"
        }
    },
    {
        question: "Нужно ли защищать health-check эндпоинты (/health, /ping)?",
        answers: [
            "Зависит от того, что они возвращают — базовые (alive/dead) можно не защищать, детальные (версии, зависимости) — да",
            "Нет, health-check всегда должен быть публичным",
            "Да, обязательно требовать аутентификацию для /health",
            "Health-check не имеет отношения к безопасности",
            "Защищать нужно только в production, в dev нет",
            "Только если используется Kubernetes, не для Docker Swarm",
            "Health-check нужно отключить на продакшене"
        ],
        correctAnswerIndex: 0,
        explanation: "/health returns {status: 'ok'} — можно публичный. Но если возвращает версии библиотек, IP БД, ключи конфигурации — это information disclosure. Минимизируйте данные или защитите basic auth.",
        link: {
            label: "Health Check Best Practices",
            url: "https://microservices.io/patterns/observability/health-check-api.html"
        }
    },
    {
        question: "Как правильно реализовать 'Soft Delete' без нарушения контроля доступа?",
        answers: [
            "Добавить поле deleted_at и ВСЕГДА фильтровать deleted IS NULL в запросах, даже для админа (или явная опция include_deleted)",
            "Просто добавить поле is_deleted и не париться",
            "Soft delete автоматически безопасен если использовать ORM",
            "Перенести удалённые записи в отдельную таблицу",
            "Использовать TRIGGER в базе данных для фильтрации",
            "Soft delete не влияет на контроль доступа",
            "Шифровать удалённые записи вместо фильтрации"
        ],
        correctAnswerIndex: 0,
        explanation: "Soft delete: риск, что `SELECT * FROM users WHERE id=?` вернёт удалённого пользователя, если забыли `AND deleted_at IS NULL`. Используйте ORM scopes/global filters или view, чтобы это применялось автоматически.",
        link: {
            label: "Soft Delete Patterns",
            url: "https://en.wikipedia.org/wiki/Soft_deletion"
        }
    },
    {
        question: "Влияет ли использование JWT без refresh tokens на BAC?",
        answers: [
            "Да, если права отобрали, но JWT ещё валиден (не истёк), пользователь продолжит иметь доступ до expiration",
            "Нет, JWT без refresh tokens самый безопасный подход",
            "Это влияет только на UX, не на безопасность",
            "JWT всегда нужно использовать с refresh tokens",
            "Проблема только для symmetric (HS256) JWT, не для asymmetric (RS256)",
            "Это решается установкой короткого TTL (5 секунд)",
            "JWT без refresh tokens вообще не используется в production"
        ],
        correctAnswerIndex: 0,
        explanation: "Проблема: уволили сотрудника, но JWT живёт ещё 8 часов (exp). Решения: короткий TTL + refresh tokens, token revocation list (сложно), или stateful sessions. Balanсируйте UX и безопасность.",
        link: {
            label: "JWT Best Practices",
            url: "https://tools.ietf.org/html/rfc8725"
        }
    },
    {
        question: "Что такое Time-Based Access Control (TBAC)?",
        answers: [
            "Контроль доступа на основе времени: права действуют только в определённые часы, дни недели или временные периоды",
            "Контроль на основе времени ответа сервера (latency)",
            "Автоматическое истечение (expiration) JWT-токенов",
            "Система контроля доступа для часовых  поясов",
            "Backup and restore на основе временных меток",
            "Time-based One-Time Password (TOTP) для 2FA",
            "Контроль версий прав доступа во времени"
        ],
        correctAnswerIndex: 0,
        explanation: "TBAC: 'Разрешить редактирование документов только пн-пт 9:00-18:00' или 'Временный доступ консультанту на 30 дней'. Часть ABAC/PBAC, атрибут — время.",
        link: {
            label: "Temporal Access Control",
            url: "https://en.wikipedia.org/wiki/Access_control"
        }
    },
    {
        question: "Как тестировать Broken Access Control в Single Page Applications (SPA)?",
        answers: [
            "Перехватывать API-запросы через прокси, тестировать backend так же, как REST API, игнорируя клиентскую маршрутизацию",
            "Только проверять роутинг на стороне клиента (React Router)",
            "SPA защищены автоматически благодаря client-side роутингу",
            "Достаточно проверки редиректов в браузере при неавторизованном доступе",
            "Тестировать только компоненты, требующие авторизации",
            "SPA не уязвимы к BAC, только к XSS",
            "Проверять только localStorage и sessionStorage"
        ],
        correctAnswerIndex: 0,
        explanation: "В SPA клиентский роутинг — это только UX. Защита должна быть на backend API. Тестируйте API: перехватите запросы, подделайте роль/токен, проверьте ответы (200 vs 403).",
        link: {
            label: "OWASP: SPA Security",
            url: "https://cheatsheetseries.owasp.org/cheatsheets/HTML5_Security_Cheat_Sheet.html"
        }
    },
    {
        question: "Может ли уязвимость в функции поитска/фильтрации привести к BAC?",
        answers: [
            "Да, если поиск не фильтрует данные по правам: GET /api/search?q=password может вернуть чужие документы со словом 'password'",
            "Нет, поиск — это всегда безопасная read-only операция",
            "Только если используется ElasticSearch, не SQL LIKE",
            "Поиск уязвим только к NoSQL Injection",
            "Это проблема только при полнотекстовом поиске",
            "Достаточно экранировать спецсимволы в запросе",
            "Автодополнение (autocomplete) всегда безопасно"
        ],
        correctAnswerIndex: 0,
        explanation: "Поиск часто ищет глобально по всем данным без учёта прав. Пример: `SELECT * FROM docs WHERE content LIKE '%query%'` вернёт приватные документы. Добавьте фильтр: `AND (owner_id=? OR is_public=1)`.",
        link: {
            label: "OWASP: Search Function Security",
            url: "https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/05-Authorization_Testing/README"
        }
    },
    {
        question: "Что такое Delegation of Authority и как это связано с BAC?",
        answers: [
            "Передача прав другому пользователю (например, 'Разрешить Bob управлять моим проектом') — требует careful implementation для предотвращения злоупотреблений",
            "Делегирование полномочий только между администраторами",
            "Автоматическое делегирование прав при увольнении сотрудника",
            "Передача ответственности за безопасность от разработчиков к DevOps",
            "Делегирование только в федеративных системах (SAML, AD FS)",
            "Это синоним импер сонификации (impersonation)",
            "Функция только для enterprise SaaS-приложений"
        ],
        correctAnswerIndex: 0,
        explanation: "Delegation: Alice даёт Bob право редактировать её файлы. Риски: Bob может делегировать дальше, отзыв сложен, audit trail запутан. Реализуйте: явное подтверждение, ограничение по времени, логирование.",
        link: {
            label: "XACML: Delegation",
            url: "http://docs.oasis-open.org/xacml/xacml-3.0-delegation-profile/v1.0/xacml-3.0-delegation-profile-v1.0.html"
        }
    },
    {
        question: "Как проверить уязвимость в функции 'Share link' (публичная ссылка)?",
        answers: [
            "Проверить, можно ли угадать/перебрать токен ссылки, нет ли rate limiting, можно ли отозвать ссылку, и логируются ли доступы",
            "Share link всегда безопасен, если используется UUID",
            "Достаточно проверить длину токена (> 16 символов)",
            "Это не уязвимость контроля доступа, а feature",
            "Share link защищён автоматически Origin заголовком",
            "Проверять нужно только наличие HTTPS",
            "Достаточно опции 'Password protect link'"
        ],
        correctAnswerIndex: 0,
        explanation: "Share links: Риски: короткий/предсказуемый токен (https://app.com/s/abc123), нет expiration, нет отзыва, нет аудита кто использовал. Best practices: long random token, TTL, logging, возможность отзыва.",
        link: {
            label: "Sharing Links Security",
            url: "https://cheatsheetseries.owasp.org/cheatsheets/Authorization_Cheat_Sheet.html"
        }
    },
    {
        question: "Нужно ли проверять права для GraphQL Subscription?",
        answers: [
            "Да, при подписке и при каждом отправленном событии, так как права могут измениться во время активной подписки",
            "Нет, subscriptions используют WebSocket, который автоматически безопасен",
            "Проверка нужна только при первичной подписке",
            "GraphQL subscriptions не уязвимы к BAC",
            "Достаточно проверки на уровне GraphQL schema",
            "Subscriptions — это read-only, поэтому безопасны",
            "Проверка нужна только для мутаций, не для subscriptions"
        ],
        correctAnswerIndex: 0,
        explanation: "Subscription: user подписался на updates проекта (права есть) → через час права отобрали → но WS-соединение активно и продолжает слать данные. Проверяйте права при каждом событии или периодически!",
        link: {
            label: "GraphQL Subscriptions Security",
            url: "https://cheatsheetseries.owasp.org/cheatsheets/GraphQL_Cheat_Sheet.html"
        }
    },
    {
        question: "Что такое Fine-Grained Authorization (FGA)?",
        answers: [
            "Детализированная авторизация на уровне отдельных полей, записей или атрибутов, а не только ролей и ресурсов",
            "Авторизация для мелких (small) файлов и данных",
            "Система штрафов (fines) за нарушение правил доступа",
            "Авторизация с точностью до миллисекунд",
            "Fine-Grained — это просто синоним RBAC",
            "Авторизация только для текстовых файлов",
            "Метод сжатия (compression) правил доступа"
        ],
        correctAnswerIndex: 0,
        explanation: "FGA: вместо 'user может читать документы' → 'user может читать поле email в document #123, но не поле salary'. Пример: Google Zanzibar, AWS Cedar. Нужно для сложных enterprise-систем.",
        link: {
            label: "Google Zanzibar (FGA)",
            url: "https://research.google/pubs/pub48190/"
        }
    },
    {
        question: "Как проверить корректность имплементации Row-Level Security (RLS) в PostgreSQL?",
        answers: [
            "Подключиться к БД от имени разных ролей и выполнить SELECT — убедиться, что каждая роль видит только свои строки",
            "RLS в PostgreSQL автоматически безопасен, проверка не нужна",
            "Достаточно просмотреть SQL-политики в документации",
            "Использовать только автоматические сканеры БД",
            "RLS работает только для INSERT, не для SELECT",
            "Проверять нужно только на production, не на dev",
            "RLS заменяет необходимость в application-level авторизации"
        ],
        correctAnswerIndex: 0,
        explanation: "RLS (Row-Level Security): БД автоматически фильтрует строки. Тестирование: CREATE ROLE user1; SET ROLE user1; SELECT * FROM projects; — должны вернуться только проекты user1. Проверьте все роли и сценарии.",
        link: {
            label: "PostgreSQL: Row Security Policies",
            url: "https://www.postgresql.org/docs/current/ddl-rowsecurity.html"
        }
    },
    {
        question: "Влияет ли использование Server-Sent Events (SSE) на контроль доступа?",
        answers: [
            "Да, SSE — это long-lived соединение, нужно периодически ревалидировать права, так как они могли измениться",
            "Нет, SSE автоматически прерывается при смене прав",
            "SSE защищён Same-Origin Policy и не требует доп. проверок",
            "SSE используется только для публичных уведомлений",
            "Достаточно проверки при установке HTTP-соединения",
            "SSE уязвим только к DoS, не к BAC",
            "SSE не поддерживает аутентификацию вообще"
        ],
        correctAnswerIndex: 0,
        explanation: "SSE: HTTP-соединение открыто часами, сервер пушит события. Если права отобрали, но соединение живо — user продолжит получать данные. Периодически проверяйте токен/права или делайте re-auth.",
        link: {
            label: "Server-Sent Events Security",
            url: "https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events"
        }
    },
    {
        question: "Можно ли использовать IP-whitelist как единственный метод контроля доступа?",
        answers: [
            "Нет, IP легко подделать или изменить (прокси, VPN), IP whitelist — это дополнительная защита, не основная",
            "Да, IP-whitelist — это самый надёжный метод",
            "Только для IPv6, не для IPv4",
            "Да, если дополнительно проверять User-Agent",
            "IP-whitelist заменяет аутентификацию полностью",
            "Только для внутренних корпоративных сетей",
            "Да, если использовать NAT и firewall"
        ],
        correctAnswerIndex: 0,
        explanation: "IP whitelist: проблемы — NAT (много пользователей с одного IP), VPN (IP меняется), shared offices, mobile users. Используйте как defense in depth + proper authentication/authorization.",
        link: {
            label: "OWASP: IP Whitelisting",
            url: "https://cheatsheetseries.owasp.org/cheatsheets/Authentication_Cheat_Sheet.html"
        }
    },
    {
        question: "Как правильно обрабатывать 403 Forbidden на клиенте для лучшего UX без ущерба безопасности?",
        answers: [
            "Показать информативное сообщение (Permission Denied), но НЕ раскрывать, какие права нужны или существует ли ресурс",
            "Редиректить на 404, чтобы скрыть существование ресурса",
            "Всегда возвращать 200 OK с пустым массивом данных",
            "Показывать детальный список необходимых прав",
            "Автоматически контактировать администратора для запроса прав",
            "Редиректить на страницу логина даже если пользователь залогинен",
            "Показывать весь stacktrace ошибки для отладки"
        ],
        correctAnswerIndex: 0,
        explanation: "403 Forbidden: информируйте user о недостатке прав, но не раскрывайте детали ('You need admin role', 'This project exists but you can't access'). Это information disclosure. Просто: 'Access Denied'.",
        link: {
            label: "HTTP 403 Best Practices",
            url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/403"
        }
    }
];
