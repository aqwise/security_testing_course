export interface QuizQuestion {
    question: string;
    answers: string[];
    correctAnswerIndex: number;
    explanation?: string;
    link?: {
        label: string;
        url: string;
    };
}

export const quizQuestions: QuizQuestion[] = [
    {
        question: "Что такое XXE?",
        answers: [
            "XML External Entity — уязвимость атаки на XML парсеры, позволяющая читать файлы и выполнять SSRF атаки",
            "XSS Cross Element — техника внедрения скриптов через пересечение элементов DOM дерева документа",
            "Extreme XML Encoding — метод оптимизации кодирования XML документов для эффективного сжатия данных",
            "XML Extension Engine — движок для расширения функциональности XML обработки в современных браузерах",
            "XPath Execution Expression — язык выполнения сложных запросов к иерархической структуре XML документов",
            "XML Encryption Extension — дополнение для шифрования чувствительных XML данных при передаче по сети",
            "XSL External Element — внешний элемент для подключения таблиц стилей к XML документам веб-приложений"
        ],
        correctAnswerIndex: 0,
        explanation: "XXE (XML External Entity) — уязвимость, возникающая при обработке XML с разрешенными внешними сущностями. Позволяет читать локальные файлы сервера, выполнять SSRF атаки и в некоторых случаях DoS.",
        link: {
            label: "OWASP: XML External Entity (XXE)",
            url: "https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing"
        }
    },
    {
        question: "Какой компонент отвечает за обработку внешних сущностей в XML?",
        answers: [
            "HTML парсер браузера обрабатывает внешние сущности и подключает ресурсы для отображения контента",
            "XML процессор/парсер обрабатывает DTD и разрешает ссылки на внешние сущности при парсинге документа",
            "JavaScript движок выполняет внешние сущности и интегрирует их в контекст выполнения веб-приложения",
            "CSS рендерер применяет стили из внешних сущностей и формирует визуальное представление документа",
            "DOM манипулятор управляет внешними сущностями и синхронизирует их с деревом объектной модели документа",
            "HTTP клиент загружает внешние сущности с удаленных серверов и кэширует их для повторного использования",
            "Schema валидатор проверяет внешние сущности на соответствие XSD схеме и отклоняет невалидные данные"
        ],
        correctAnswerIndex: 1,
        explanation: "XML процессор (парсер) отвечает за разбор XML документа и обработку внешних сущностей, определенных в DTD. При отсутствии защиты он может загружать произвольные файлы.",
        link: {
            label: "PortSwigger: What is XML external entity injection?",
            url: "https://portswigger.net/web-security/xxe"
        }
    },
    {
        question: "Что позволяет сделать успешная XXE атака?",
        answers: [
            "Только изменить цвет фона веб-страницы через внедрение кастомных CSS стилей",
            "Читать локальные файлы сервера, выполнять SSRF для доступа к внутренним ресурсам, DoS через рекурсию",
            "Внедрять SQL запросы напрямую в базу данных для извлечения конфиденциальных данных пользователей",
            "Взламывать WiFi сеть организации через подбор паролей роутера и перехват сетевого трафика",
            "Модифицировать JavaScript код приложения для внедрения вредоносной логики в клиентскую часть",
            "Получать доступ к cookie файлам пользователей для захвата сессий и имперсонации аккаунтов",
            "Обходить механизмы аутентификации через эксплуатацию уязвимостей в системе управления сессиями"
        ],
        correctAnswerIndex: 1,
        explanation: "XXE позволяет читать локальные файлы (например, /etc/passwd), выполнять SSRF запросы к внутренним сервисам, а также проводить DoS атаки через Billion Laughs.",
        link: {
            label: "OWASP: XXE Attack Types",
            url: "https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing"
        }
    },
    {
        question: "Как выглядит определение сущности (Entity) в DTD?",
        answers: [
            "<!ENTITY name 'value'> — синтаксис объявления сущности в Document Type Definition для XML документа",
            "<DEFINE name='value'> — альтернативный синтаксис определения сущности используемый в старых версиях XML",
            "{ entity: name, value: value } — JSON-подобная нотация для объявления сущностей в современных XML парсерах",
            "@entity name = value — декоративный синтаксис аннотаций для определения сущностей в XML Schema Definition",
            "<entity name='value'/> — самозакрывающийся XML тег для inline объявления сущностей внутри документа",
            "SET ENTITY name TO 'value' — SQL-подобный синтаксис определения сущностей в XML Query Language",
            "var entity_name = 'value' — JavaScript-подобное объявление сущностей для динамической генерации XML"
        ],
        correctAnswerIndex: 0,
        explanation: "Сущности в DTD объявляются через <!ENTITY>. Например: <!ENTITY xxe SYSTEM 'file:///etc/passwd'>",
        link: {
            label: "W3C: Entity Declarations",
            url: "https://www.w3.org/TR/REC-xml/#sec-entity-decl"
        }
    },
    {
        question: "Какой URI схема часто используется для чтения файлов при XXE?",
        answers: [
            "file:// — схема для доступа к локальной файловой системе сервера через XML External Entity",
            "read:// — специализированная схема для чтения файлов с ограниченными правами доступа в XML парсерах",
            "local:// — схема для обращения к локальным ресурсам с автоматической проверкой прав безопасности",
            "fs:// — файловая система схема для кроссплатформенного доступа к файлам через XML сущности",
            "disk:// — схема прямого доступа к дисковым ресурсам минуя стандартную файловую систему операционной системы",
            "resource:// — универсальная схема для загрузки различных типов ресурсов включая локальные файлы",
            "path:// — схема для указания абсолютных путей к файлам с поддержкой переменных окружения"
        ],
        correctAnswerIndex: 0,
        explanation: "Схема file:// используется для чтения локальных файлов. Пример: <!ENTITY xxe SYSTEM 'file:///etc/passwd'>",
        link: {
            label: "PortSwigger: Exploiting XXE to retrieve files",
            url: "https://portswigger.net/web-security/xxe/lab-exploiting-xxe-to-retrieve-files"
        }
    },
    {
        question: "Что такое 'Billion Laughs' атака?",
        answers: [
            "DoS атака через рекурсивное расширение XML сущностей, приводящая к исчерпанию памяти сервера",
            "Атака смехом с использованием эмодзи для обхода фильтров безопасности веб-приложения",
            "XSS атака с эмодзи символами для внедрения вредоносного JavaScript кода в DOM дерево",
            "Атака на логин форму через автоматизированный перебор паролей с юмористическими комбинациями",
            "Социальная инженерия через рассылку юмористического контента с вредоносными вложениями получателям",
            "Фишинговая атака использующая забавные мемы для снижения бдительности жертв и кражи данных",
            "Brute-force атака с генерацией случайных символов имитирующих смех для обхода rate limiting"
        ],
        correctAnswerIndex: 0,
        explanation: "Billion Laughs — DoS атака через экспоненциальное расширение вложенных сущностей, что приводит к исчерпанию памяти и падению сервера.",
        link: {
            label: "Wikipedia: Billion laughs attack",
            url: "https://en.wikipedia.org/wiki/Billion_laughs_attack"
        }
    },
    {
        question: "Что такое Blind XXE?",
        answers: [
            "XXE, где вывод данных не возвращается в ответе приложения и требует out-of-band каналов",
            "XXE, которое не видно в логах сервера и не оставляет следов в системе мониторинга",
            "XXE, использующее невидимые символы Unicode для обхода валидации входных данных приложения",
            "XXE для слепых пользователей с использованием специальных accessibility функций браузера",
            "XXE, работающее только в темное время суток когда активность мониторинга снижена",
            "XXE через зашифрованные каналы связи которые нельзя проинспектировать стандартными инструментами",
            "XXE атака маскирующаяся под легитимный трафик и не детектируемая WAF системами защиты"
        ],
        correctAnswerIndex: 0,
        explanation: "Blind XXE — уязвимость, где результат эксплуатации не виден напрямую в ответе. Для извлечения данных используются out-of-band техники (DNS, HTTP на внешний сервер).",
        link: {
            label: "PortSwigger: Blind XXE vulnerabilities",
            url: "https://portswigger.net/web-security/xxe/blind"
        }
    },
    {
        question: "Как можно извлечь данные при Blind XXE?",
        answers: [
            "Никак, данные не могут быть извлечены если отсутствует прямой вывод в ответе сервера",
            "Через OOB (Out-of-Band) канал, например DNS или HTTP запрос на сервер атакующего с данными",
            "Только угадыванием содержимого файлов через анализ времени ответа и побочных каналов информации",
            "Через SQL Injection комбинированную с XXE для записи результатов в доступную таблицу базы данных",
            "Используя WebSocket соединение для двунаправленной передачи извлеченных данных в реальном времени",
            "Через механизм postMessage API для передачи данных между различными origin доменами приложения",
            "Создавая временные файлы на сервере с извлеченными данными и загружая их через публичные endpoint"
        ],
        correctAnswerIndex: 1,
        explanation: "При Blind XXE данные извлекаются через out-of-band каналы: DNS запросы с данными в поддомене или HTTP запросы на контролируемый сервер (например, Burp Collaborator).",
        link: {
            label: "PortSwigger: Exploiting blind XXE to exfiltrate data using a malicious external DTD",
            url: "https://portswigger.net/web-security/xxe/blind/lab-xxe-with-out-of-band-exfiltration"
        }
    },
    {
        question: "Какой протокол в Java может использоваться для листинга директорий при XXE (в старых версиях)?",
        answers: [
            "netdoc:// — протокол в старых версиях Java для доступа к сетевой документации и листинга директорий",
            "dir:// — специальный протокол для прямого листинга содержимого директорий файловой системы",
            "ls:// — аналог Unix команды ls для получения списка файлов через XML External Entity",
            "list:// — универсальный протокол для перечисления ресурсов доступных в контексте приложения",
            "enumerate:// — протокол для полного перечисления файловой структуры с рекурсивным обходом директорий",
            "browse:// — протокол для навигации по файловой системе с поддержкой wildcard паттернов",
            "scan:// — протокол для сканирования и инвентаризации файлов с фильтрацией по расширениям"
        ],
        correctAnswerIndex: 0,
        explanation: "В старых версиях Java (до обновлений безопасности) протокол netdoc:// мог использоваться для листинга директорий. Пример: <!ENTITY xxe SYSTEM 'netdoc:///etc/'>",
        link: {
            label: "XXE Cheat Sheet: Java-specific protocols",
            url: "https://mohemiv.com/all/exploiting-xxe-with-local-dtd-files/"
        }
    },
    {
        question: "Что такое DTD?",
        answers: [
            "Document Type Definition — определение структуры и правил валидации XML документа с объявлением сущностей",
            "Data Transfer Definition — спецификация для безопасной передачи данных между различными системами",
            "Direct Text Display — формат для прямого отображения текстового контента без дополнительной обработки",
            "Document Text Description — описание текстового содержимого документа в машиночитаемом формате метаданных",
            "Dynamic Type Detector — механизм автоматического определения типов данных в слабо типизированных языках",
            "Database Transaction Descriptor — дескриптор для управления транзакциями в реляционных базах данных",
            "Distributed Task Delegation — система делегирования задач в распределенных вычислительных системах"
        ],
        correctAnswerIndex: 0,
        explanation: "DTD (Document Type Definition) определяет структуру XML, элементы, атрибуты и сущности. Именно в DTD объявляются внешние сущности, которые эксплуатируются при XXE.",
        link: {
            label: "W3C: Document Type Definition",
            url: "https://www.w3.org/TR/REC-xml/#dt-doctype"
        }
    },
    {
        question: "Можно ли выполнить XXE через SVG файл?",
        answers: [
            "Нет, SVG это картинка в растровом формате не содержащая исполняемого кода или внешних сущностей",
            "Да, SVG основан на XML и может содержать DTD с внешними сущностями для эксплуатации XXE",
            "Только если SVG анимированный и содержит JavaScript код для динамической загрузки ресурсов",
            "Только в браузере IE версии 6-8 из-за специфичной реализации SVG рендеринга",
            "Возможно только при конвертации SVG в PNG с сохранением метаданных и встроенных скриптов",
            "Только если SVG файл больше 1 МБ и содержит сложные векторные пути и градиенты",
            "Только через встроенные CSS стили в SVG которые загружают внешние шрифты и ресурсы"
        ],
        correctAnswerIndex: 1,
        explanation: "SVG — это XML формат. При загрузке SVG файла серверное приложение может парсить его как XML, что открывает возможность для XXE атаки через вредоносные SVG изображения.",
        link: {
            label: "PortSwigger: XXE via file upload",
            url: "https://portswigger.net/web-security/xxe/lab-xxe-via-file-upload"
        }
    },
    {
        question: "Как называется внешняя сущность, которая ссылается на другой файл?",
        answers: [
            "External Entity — сущность в DTD ссылающаяся на внешний файл через SYSTEM или PUBLIC идентификатор",
            "Outer Entity — сущность находящаяся вне основного документа в отдельном пространстве имен",
            "File Entity — специализированная сущность для работы исключительно с файловыми ресурсами",
            "Import Entity — сущность импортирующая содержимое других XML документов в текущий контекст",
            "Reference Entity — сущность создающая ссылку на другие объекты в объектной модели документа",
            "Link Entity — сущность устанавливающая связь между различными частями распределенного XML документа",
            "Resource Entity — универсальная сущность для доступа к любым типам ресурсов включая файлы"
        ],
        correctAnswerIndex: 0,
        explanation: "External Entity (внешняя сущность) — это сущность, которая ссылается на внешний ресурс. Объявляется через <!ENTITY name SYSTEM 'URI'>.",
        link: {
            label: "OWASP: External Entity",
            url: "https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing"
        }
    },
    {
        question: "Какое ключевое слово используется для объявления внешней сущности?",
        answers: [
            "SYSTEM — ключевое слово DTD для объявления внешней сущности с указанием URI локального или удаленного ресурса",
            "EXTERNAL — директива для явного указания что сущность загружается из внешнего источника данных",
            "FILE — спецификатор для объявления сущностей ссылающихся на файлы локальной файловой системы",
            "IMPORT — ключевое слово для импорта содержимого внешних документов в текущий XML контекст",
            "LOAD — директива для загрузки внешних ресурсов с кэшированием для повторного использования",
            "FETCH — команда для извлечения данных из внешних источников с обработкой ошибок загрузки",
            "INCLUDE — инструкция для включения внешнего контента аналогично директиве #include в C/C++"
        ],
        correctAnswerIndex: 0,
        explanation: "SYSTEM используется для объявления внешней сущности. Пример: <!ENTITY xxe SYSTEM 'file:///etc/passwd'>. Также существует PUBLIC для публичных идентификаторов.",
        link: {
            label: "W3C: External Entity Declaration",
            url: "https://www.w3.org/TR/REC-xml/#sec-external-ent"
        }
    },
    {
        question: "Что такое Parameter Entities в DTD?",
        answers: [
            "Сущности, используемые только внутри DTD (начинаются с %) для модульных определений структуры",
            "Сущности для передачи параметров URL в запросах и формирования динамических XML документов",
            "Сущности для SQL запросов с параметризацией для безопасного выполнения запросов к БД",
            "Сущности для CSS переменных применяемых к стилизации XML документов при рендеринге",
            "Сущности для конфигурационных параметров приложения загружаемых из внешних файлов настроек",
            "Сущности для передачи аргументов в XSL трансформации при преобразовании XML документов",
            "Сущности для JavaScript переменных используемых в клиентской логике обработки XML данных"
        ],
        correctAnswerIndex: 0,
        explanation: "Parameter Entities (параметрические сущности) используются внутри DTD и начинаются с %. Пример: <!ENTITY % file SYSTEM 'file:///etc/passwd'>. Часто используются в техниках Blind XXE.",
        link: {
            label: "W3C: Parameter Entity References",
            url: "https://www.w3.org/TR/REC-xml/#dt-PERef"
        }
    },
    {
        question: "Какой формат данных безопаснее XML в плане XXE?",
        answers: [
            "JSON — не имеет концепции внешних сущностей и DTD что исключает XXE уязвимости",
            "HTML4 — старый формат разметки который более безопасен благодаря простому парсингу",
            "SGML — предшественник XML с более строгими правилами обработки внешних ресурсов",
            "Никакой формат не безопасен все форматы данных имеют собственные уязвимости безопасности",
            "CSV — табличный формат данных который наиболее защищен от injection атак любых типов",
            "YAML — формат сериализации данных с встроенными механизмами проверки типов и валидации",
            "Protocol Buffers — бинарный формат с жесткой схемой что предотвращает любые injection атаки"
        ],
        correctAnswerIndex: 0,
        explanation: "JSON безопаснее в плане XXE, так как не имеет концепции DTD и внешних сущностей. Однако имеет свои риски (десериализация).",
        link: {
            label: "OWASP: Use less complex data formats",
            url: "https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html"
        }
    },
    {
        question: "Как отключить XXE в большинстве парсеров?",
        answers: [
            "Запретить обработку DTD и внешних сущностей (disallow-doctype-decl, disable external entities)",
            "Включить фаервол на сервере для блокировки всех исходящих запросов к файловой системе",
            "Использовать HTTPS протокол для шифрования трафика и предотвращения перехвата XXE атак",
            "Перезагрузить сервер после каждого запроса для сброса состояния XML парсера в памяти",
            "Установить антивирус программу для детектирования вредоносных XML документов в реальном времени",
            "Использовать только зашифрованные XML документы с цифровой подписью для проверки аутентичности",
            "Ограничить размер XML документов до 1 КБ чтобы предотвратить загрузку больших файлов"
        ],
        correctAnswerIndex: 0,
        explanation: "XXE отключается через настройки парсера: отключить DTD processing, external entities, external DTD. Конкретные настройки зависят от языка/библиотеки.",
        link: {
            label: "OWASP: XXE Prevention Cheat Sheet",
            url: "https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html"
        }
    },
    {
        question: "Может ли XXE привести к RCE (Remote Code Execution)?",
        answers: [
            "Никогда, XXE ограничен только чтением файлов и не может выполнять произвольный код",
            "Да, в редких случаях (например, через php://expect в PHP модуле expect или десериализацию)",
            "Всегда, XXE автоматически приводит к выполнению кода на целевой системе без дополнительных условий",
            "Только на Windows системах через специфичные COM объекты и ActiveX компоненты в XML парсере",
            "Только при комбинации с SQL Injection через стек вызовов в stored procedures базы данных",
            "Только в контейнеризированных средах через escape из Docker контейнера используя XXE векторы",
            "Только если целевой сервер работает на устаревшем ядре Linux с известными уязвимостями privilege escalation"
        ],
        correctAnswerIndex: 1,
        explanation: "В редких случаях XXE может привести к RCE: через php://expect wrapper в PHP (если модуль установлен), phar:// десериализацию или другие специфичные сценарии.",
        link: {
            label: "PayloadsAllTheThings: XXE to RCE",
            url: "https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XXE%20Injection#xxe-to-rce"
        }
    },
    {
        question: "Какой Content-Type обычно указывает на XML?",
        answers: [
            "application/xml или text/xml — стандартные MIME типы для передачи XML документов по HTTP",
            "application/json — формат данных который всегда содержит XML внутри JSON строк",
            "text/plain — универсальный тип контента автоматически определяющий XML по содержимому",
            "image/jpeg — графический формат который может содержать XML метаданные в EXIF",
            "text/html — HTML документы которые являются подмножеством XML с менее строгим синтаксисом",
            "application/octet-stream — бинарный формат для передачи сжатых XML документов в архиве",
            "multipart/form-data — тип для форм где XML может быть одним из полей данных"
        ],
        correctAnswerIndex: 0,
        explanation: "Content-Type: application/xml или text/xml указывают на XML. Также существуют application/soap+xml, application/xhtml+xml и другие XML-based типы.",
        link: {
            label: "MDN: MIME types for XML",
            url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types"
        }
    },
    {
        question: "Можно ли сменить Content-Type на application/xml и попытаться атаковать JSON эндпоинт?",
        answers: [
            "Нет, сервер всегда строго проверяет Content-Type и отклоняет несоответствующие запросы",
            "Да, некоторые фреймворки могут переключить парсер на XML если поддерживают content negotiation",
            "Всегда сработает, все серверы автоматически парсят любой контент независимо от заголовков",
            "Это сломает интернет, изменение Content-Type вызовет каскадные ошибки в сетевом стеке",
            "Возможно только на localhost серверах в development окружении без production настроек",
            "Только если одновременно изменить метод запроса с POST на PUT что запутает парсер",
            "Только в мобильных приложениях где фреймворки менее строго проверяют MIME типы"
        ],
        correctAnswerIndex: 1,
        explanation: "Некоторые фреймворки (например, Spring) поддерживают multiple content types и могут парсить как JSON, так и XML. Смена Content-Type может активировать XML парсер.",
        link: {
            label: "PortSwigger: Content type conversion",
            url: "https://portswigger.net/web-security/xxe"
        }
    },
    {
        question: "Что такое XInclude?",
        answers: [
            "Механизм включения одного XML в другой, может использоваться для XXE если парсер его поддерживает",
            "Включение JavaScript библиотек в HTML документы для расширения клиентской функциональности приложения",
            "Включение CSS стилей в XML документы для применения визуального форматирования при рендеринге",
            "Функция PHP для инклюда файлов в текущий скрипт что может привести к local file inclusion",
            "Директива препроцессора C++ для включения заголовочных файлов в компиляционный модуль",
            "Apache модуль для server-side includes позволяющий встраивать динамический контент в статические страницы",
            "Механизм импорта модулей в Python через relative imports для организации кода в пакеты"
        ],
        correctAnswerIndex: 0,
        explanation: "XInclude — стандарт W3C для включения одного XML документа в другой. Может использоваться для XXE даже если контроль над DTD ограничен: <xi:include href='file:///etc/passwd'/>",
        link: {
            label: "PortSwigger: XInclude attacks",
            url: "https://portswigger.net/web-security/xxe/lab-xinclude-attack"
        }
    },
    {
        question: "Как выглядит атака через XInclude?",
        answers: [
            "<xi:include href='file:///etc/passwd'/> — вставка во вложенный XML элемент для эксплуатации XXE",
            "<include src='/etc/passwd'/> — HTML5 синтаксис для включения внешних файлов в документ",
            "<import file='/etc/passwd'/> — JavaScript импорт файлов для загрузки модулей в браузере",
            "<require path='/etc/passwd'/> — Node.js синтаксис для подключения файлов как модулей CommonJS",
            "<load resource='/etc/passwd'/> — универсальная директива для загрузки ресурсов любых типов",
            "<fetch url='/etc/passwd'/> — Fetch API синтаксис для асинхронной загрузки файлов по URL",
            "<use file='/etc/passwd'/> — SVG синтаксис для переиспользования графических элементов из файлов"
        ],
        correctAnswerIndex: 0,
        explanation: "XInclude использует namespace xi и выглядит как: <xi:include xmlns:xi='http://www.w3.org/2001/XInclude' href='file:///etc/passwd'/>",
        link: {
            label: "W3C: XInclude Specification",
            url: "https://www.w3.org/TR/xinclude/"
        }
    },
    {
        question: "Какая утилита помогает эксплуатировать XXE OOB?",
        answers: [
            "Burp Collaborator — сервис для детектирования out-of-band взаимодействий при blind XXE атаках",
            "Notepad — текстовый редактор для ручного создания и редактирования XML пейлоадов XXE",
            "Calculator — утилита для вычисления размеров пейлоадов и статистики успешных инъекций",
            "Paint — графический редактор для визуализации структуры XML документов и DTD схем",
            "Excel — табличный процессор для организации коллекций XXE векторов и результатов тестирования",
            "Windows Media Player — мультимедийный проигрыватель с встроенным XML парсером для SVG файлов",
            "Task Manager — системная утилита для мониторинга использования ресурсов при DoS атаках"
        ],
        correctAnswerIndex: 0,
        explanation: "Burp Collaborator — инструмент для детекции out-of-band взаимодействий. Предоставляет уникальный домен для получения DNS и HTTP запросов при blind XXE.",
        link: {
            label: "PortSwigger: Burp Collaborator",
            url: "https://portswigger.net/burp/documentation/collaborator"
        }
    },
    {
        question: "Что делает CDATA в XML?",
        answers: [
            "Позволяет использовать символы, которые иначе интерпретировались бы как разметка XML без экранирования",
            "Шифрует данные внутри секции используя встроенные криптографические алгоритмы XML парсера",
            "Сжимает данные для уменьшения размера XML документа при передаче по медленным каналам связи",
            "Удаляет данные из финального документа оставляя их только в исходном коде для разработчиков",
            "Конвертирует текстовые данные в Base64 формат для безопасной передачи бинарных данных",
            "Проверяет корректность данных согласно встроенным правилам валидации XML Schema Definition",
            "Кэширует данные в памяти парсера для ускорения повторной обработки одинаковых XML документов"
        ],
        correctAnswerIndex: 0,
        explanation: "CDATA (Character Data) позволяет включить текст, содержащий символы <, >, & без экранирования. Синтаксис: <![CDATA[содержимое]]>",
        link: {
            label: "W3C: CDATA Sections",
            url: "https://www.w3.org/TR/REC-xml/#sec-cdata-sect"
        }
    },
    {
        question: "Зачем использовать CDATA при эксфильтрации файлов через XXE?",
        answers: [
            "Чтобы спецсимволы в файле (например <, >) не ломали XML структуру при включении содержимого",
            "Для красоты XML документа и улучшения читаемости кода при ревью безопасности приложения",
            "Для скорости обработки данных парсером так как CDATA секции обрабатываются быстрее обычного текста",
            "Это обязательно по стандарту W3C для любых внешних данных загружаемых через DTD сущности",
            "Для совместимости со старыми версиями браузеров которые не поддерживают современный XML синтаксис",
            "Для автоматической конвертации кодировок при передаче данных между различными системами",
            "Для активации специальных режимов парсера позволяющих обходить защиту от XXE атак"
        ],
        correctAnswerIndex: 0,
        explanation: "При чтении файлов с помощью XXE, содержимое может включать <, >, что сломает XML. CDATA предотвращает это, оборачивая данные в <![CDATA[...]]>.",
        link: {
            label: "HackTricks: XXE - Exploiting with CDATA",
            url: "https://book.hacktricks.xyz/pentesting-web/xxe-xee-xml-external-entity"
        }
    },
    {
        question: "Какой протокол (wrapper) в PHP позволяет кодировать данные в Base64?",
        answers: [
            "php://filter/read=convert.base64-encode/resource= — PHP stream filter для кодирования в Base64",
            "base64:// — прямой wrapper для автоматического кодирования любого ресурса в Base64 формат",
            "encode:// — универсальный wrapper поддерживающий множество кодировок включая Base64 и URL encoding",
            "crypt:// — криптографический wrapper для шифрования и кодирования данных различными алгоритмами",
            "convert:// — wrapper для конвертации между различными форматами данных и кодировками символов",
            "transform:// — wrapper для применения различных трансформаций к данным включая кодирование",
            "codec:// — универсальный кодек wrapper для кодирования и декодирования различных форматов данных"
        ],
        correctAnswerIndex: 0,
        explanation: "PHP stream filter позволяет читать и кодировать файлы. Пример XXE: <!ENTITY xxe SYSTEM 'php://filter/read=convert.base64-encode/resource=/etc/passwd'>",
        link: {
            label: "PHP: Stream Filters",
            url: "https://www.php.net/manual/en/filters.convert.php"
        }
    },
    {
        question: "Может ли XXE использоваться для SSRF?",
        answers: [
            "Да, заставляя сервер делать HTTP запросы к внутренним ресурсам недоступным из интернета",
            "Нет, XXE ограничен только локальной файловой системой и не может делать сетевые запросы",
            "Только для внешних ресурсов в интернете но не для внутренних сервисов организации",
            "Только для HTTPS запросов с валидными SSL сертификатами подписанными доверенным CA",
            "Только для FTP серверов работающих в passive mode на стандартных портах 20 и 21",
            "Только для WebSocket соединений установленных через специальные ws:// protocol wrapper",
            "Только для GraphQL endpoint которые принимают XML запросы вместо стандартного JSON"
        ],
        correctAnswerIndex: 0,
        explanation: "XXE может использоваться для SSRF, заставляя парсер делать HTTP запросы к внутренним сервисам. Пример: <!ENTITY xxe SYSTEM 'http://internal-server/admin'>",
        link: {
            label: "PortSwigger: Exploiting XXE to perform SSRF",
            url: "https://portswigger.net/web-security/xxe/lab-exploiting-xxe-to-perform-ssrf"
        }
    },
    {
        question: "Какой риск несет SOAP сервис?",
        answers: [
            "SOAP основан на XML, поэтому потенциально уязвим к XXE если internal DTD processing не отключен",
            "Никакого риска так как SOAP это устаревший протокол который больше не используется в production",
            "SOAP устарел и безопасен благодаря отсутствию активной разработки и закрытию всех уязвимостей",
            "SOAP это мыло для ручной стирки которое не имеет отношения к веб-сервисам и безопасности",
            "SOAP сервисы работают только через HTTPS что автоматически защищает от всех XML атак",
            "SOAP использует бинарный протокол передачи данных что исключает возможность XXE инъекций",
            "SOAP имеет встроенную защиту от XXE на уровне спецификации протокола версии 1.2+"
        ],
        correctAnswerIndex: 0,
        explanation: "SOAP использует XML для обмена сообщениями. При отсутствии защиты SOAP сервисы уязвимы к XXE атакам при обработке входящих запросов.",
        link: {
            label: "OWASP: XXE in SOAP",
            url: "https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing"
        }
    },
    {
        question: "Что такое 'Classic XXE'?",
        answers: [
            "Когда результат внедрения сущности виден напрямую в ответе сервера без дополнительных техник",
            "XXE через музыкальные файлы MP3 содержащие вредоносные ID3 теги в XML формате",
            "XXE 90-х годов когда уязвимость была впервые обнаружена в ранних XML парсерах",
            "XXE без использования XML файлов работающее через альтернативные форматы данных",
            "XXE атака использующая только классические литературные цитаты в payload для обхода фильтров",
            "XXE через классическую музыку в формате MIDI конвертированную в XML нотацию",
            "XXE в классических desktop приложениях написанных на C++ с использованием libxml2"
        ],
        correctAnswerIndex: 0,
        explanation: "Classic (in-band) XXE — когда содержимое внешней сущности возвращается напрямую в ответе приложения, позволяя сразу видеть результат.",
        link: {
            label: "PortSwigger: Exploiting XXE to retrieve files",
            url: "https://portswigger.net/web-security/xxe"
        }
    },
    {
        question: "Как определить, что сервер уязвим к Blind XXE?",
        answers: [
            "По DNS/HTTP запросу на ваш контролируемый сервер-логгер через out-of-band канал",
            "По ошибке 500 Internal Server Error которая всегда указывает на успешную XXE инъекцию",
            "По долгой загрузке страницы что свидетельствует о чтении больших файлов с диска",
            "По изменению цвета фона страницы которое происходит при парсинге вредоносного XML",
            "По появлению alert окна в браузере с содержимым прочитанного файла",
            "По изменению cookie значений которые модифицируются при успешной XXE атаке",
            "По redirect на external домен который указывает на обработку внешних сущностей"
        ],
        correctAnswerIndex: 0,
        explanation: "Blind XXE детектируется через out-of-band каналы: сервер делает DNS lookup или HTTP запрос на домен атакующего (например, Burp Collaborator), подтверждая уязвимость.",
        link: {
            label: "PortSwigger: Detecting blind XXE using out-of-band techniques",
            url: "https://portswigger.net/web-security/xxe/blind"
        }
    },
    {
        question: "Какой инструмент автоматизации поиска уязвимостей ищет XXE?",
        answers: [
            "Burp Suite Scanner / OWASP ZAP — автоматические сканеры с встроенными проверками XXE уязвимостей",
            "Photoshop — графический редактор для обработки изображений не связанный с поиском уязвимостей",
            "Excel — табличный процессор для работы с данными не предназначенный для security тестирования",
            "Word — текстовый процессор для создания документов без функций анализа безопасности приложений",
            "PowerPoint — программа для презентаций не имеющая инструментов для тестирования на проникновение",
            "Windows Calculator — калькулятор для математических вычислений без возможностей сканирования",
            "Notepad++ — текстовый редактор с подсветкой синтаксиса но без функций автоматического поиска XXE"
        ],
        correctAnswerIndex: 0,
        explanation: "Burp Suite Scanner и OWASP ZAP имеют встроенные чеки для детекции XXE. Также существуют специализированные инструменты вроде XXEinjector.",
        link: {
            label: "OWASP ZAP: XXE Detection",
            url: "https://www.zaproxy.org/"
        }
    },
    {
        question: "Является ли функция `libxml_disable_entity_loader(true)` в PHP защитой?",
        answers: [
            "Да, она отключает загрузку внешних сущностей для старых версий PHP до 8.0 обеспечивая защиту",
            "Нет, она включает загрузку всех типов внешних сущностей что создает дополнительные уязвимости",
            "Она удаляет PHP интерпретатор с сервера что делает веб-приложение полностью неработоспособным",
            "Она только для HTML парсинга и не влияет на обработку XML документов в приложении",
            "Это устаревшая функция которая была удалена из PHP и больше не доступна для использования",
            "Функция предназначена для оптимизации производительности а не для безопасности приложений",
            "Она работает только в режиме CLI и игнорируется при выполнении через веб-сервер Apache/Nginx"
        ],
        correctAnswerIndex: 0,
        explanation: "libxml_disable_entity_loader(true) отключает загрузку внешних сущностей в PHP до версии 8.0. В PHP 8.0+ это поведение по умолчанию и функция deprecated.",
        link: {
            label: "PHP: libxml_disable_entity_loader",
            url: "https://www.php.net/manual/en/function.libxml-disable-entity-loader.php"
        }
    },
    {
        question: "Можно ли использовать XXE для сканирования портов внутренней сети?",
        answers: [
            "Да, через SSRF меняя порт в URL и анализируя различия в ответах или времени выполнения",
            "Нет, XXE работает только с файловой системой и не может делать сетевые подключения",
            "Только 80 порт доступен для сканирования так как XML парсеры поддерживают только HTTP",
            "Только 443 порт можно сканировать через HTTPS соединения с валидными SSL сертификатами",
            "Сканирование портов через XXE невозможно из-за ограничений TCP/IP протокола в XML парсерах",
            "Только порты выше 1024 доступны так как privileged порты защищены на уровне операционной системы",
            "Только UDP порты можно сканировать в то время как TCP порты недоступны для XXE атак"
        ],
        correctAnswerIndex: 0,
        explanation: "XXE можно использовать для port scanning через SSRF: меняя порт в URL (http://internal:PORT/) и анализируя время ответа или ошибки, можно определить открытые порты.",
        link: {
            label: "HackTricks: XXE - SSRF",
            url: "https://book.hacktricks.xyz/pentesting-web/xxe-xee-xml-external-entity#ssrf"
        }
    },
    {
        question: "Что такое 'External DTD'?",
        answers: [
            "DTD схема загружаемая из внешнего файла или URL вместо inline определения в документе",
            "DTD для внешних пользователей приложения ограничивающая доступные теги и атрибуты XML",
            "DTD вне компьютера хранящаяся на физических носителях для offline валидации документов",
            "Термин не существует в спецификации XML и относится к неофициальным расширениям стандарта",
            "DTD для экспортируемых данных используемая при обмене XML файлами между организациями",
            "DTD внешнего вида определяющая визуальное представление XML при рендеринге в браузере",
            "DTD для external API endpoints описывающая формат запросов и ответов web сервисов"
        ],
        correctAnswerIndex: 0,
        explanation: "External DTD — DTD, загружаемая из внешнего источника. Синтаксис: <!DOCTYPE root SYSTEM 'http://evil.com/evil.dtd'>.",
        link: {
            label: "W3C: External Subset",
            url: "https://www.w3.org/TR/REC-xml/#dt-extsubset"
        }
    },
    {
        question: "Как атаковать, если внутренние сущности запрещены, но внешние DTD разрешены?",
        answers: [
            "Использовать OOB XXE через parameter entities во внешнем DTD файле на контролируемом сервере",
            "Сдаться и переключиться на поиск других уязвимостей так как XXE невозможен в этом случае",
            "Использовать SQL Injection для обхода ограничений на entities и получения доступа к данным",
            "Использовать XSS для внедрения JavaScript который обойдет restrictions на стороне клиента",
            "Применить brute force атаку на парсер до тех пор пока ограничения не будут сняты",
            "Использовать DNS rebinding для изменения IP адреса external DTD на localhost в момент загрузки",
            "Отправить множество запросов с разными DTD пока не найдется незащищенная комбинация настроек"
        ],
        correctAnswerIndex: 0,
        explanation: "Если внутренние entities запрещены, но external DTD разрешены, можно использовать parameter entities в external DTD для OOB XXE эксплуатации.",
        link: {
            label: "PortSwigger: Exploiting blind XXE to exfiltrate data using a malicious external DTD",
            url: "https://portswigger.net/web-security/xxe/blind/lab-xxe-with-out-of-band-exfiltration"
        }
    },
    {
        question: "Какой протокол позволяет листить файлы в Java приложениях (Oracle JDK)?",
        answers: [
            "gopher:// — универсальный протокол для различных целей включая некоторые специфичные случаи",
            "netdoc:// (в старых версиях) или file:// (если директория) — для листинга содержимого папок",
            "java:// — специальный протокол для доступа к classpath ресурсам и внутренним классам JVM",
            "jar:// — протокол для чтения файлов из JAR архивов но не для листинга директорий ФС"
        ],
        correctAnswerIndex: 1,
        explanation: "В старых версиях Oracle JDK протокол netdoc:// позволял листить директории. file:// может показать содержимое директории в некоторых парсерах.",
        link: {
            label: "Exploit-DB: netdoc protocol",
            url: "https://www.exploit-db.com/docs/english/44889-exploiting-xxe-vulnerabilities-in-iis-.net.pdf"
        }
    },
    {
        question: "Что делать, если WAF блокирует слово SYSTEM?",
        answers: [
            "Использовать PUBLIC идентификатор который может не фильтроваться WAF или encoding обфускацию",
            "Использовать PRIVATE — альтернативное ключевое слово для объявления internal сущностей",
            "Использовать HIDDEN — специальное ключевое слово для скрытых сущностей невидимых для WAF",
            "Использовать SECRET — обфусцированный вариант SYSTEM который обходит большинство фильтров",
            "Отказаться от XXE атаки так как обход WAF в этом случае технически невозможен",
            "Использовать ROT13 кодирование слова SYSTEM чтобы запутать signature detection WAF",
            "Использовать Unicode нормализацию для замены латинских символов на похожие кириллические буквы"
        ],
        correctAnswerIndex: 0,
        explanation: "Если WAF блокирует SYSTEM, можно попробовать PUBLIC идентификатор, encoding tricks (UTF-16), case variations или parameter entities.",
        link: {
            label: "WAF Bypass Techniques",
            url: "https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XXE%20Injection#waf-bypass"
        }
    },
    {
        question: "Может ли XXE возникнуть при парсинге Excel файлов (.xlsx)?",
        answers: [
            "Да, так как .xlsx это ZIP архив с XML файлами внутри парсящимися при открытии документа",
            "Нет, это бинарный формат полностью несовместимый с XML и текстовыми представлениями данных",
            "Только в CSV файлах которые являются текстовым форматом совместимым с XXE инъекциямиXX",
            "Только в PDF документах где XML используется для хранения метаданных и форм XFA",
            "Excel файлы используют проприетарный Microsoft формат полностью защищенный от XXE атак",
            "Только в старых .xls файлах в то время как современные .xlsx файлы безопасны по умолчанию",
            "XXE возможен только при экспорте Excel в XML формат но не при работе с нативными файлами"
        ],
        correctAnswerIndex: 0,
        explanation: ".xlsx файлы — это ZIP архивы с XML внутри. При обработке на сервере (парсинг, конвертация) уязвимый XML парсер может быть эксплуатирован через вредоносный .xlsx.",
        link: {
            label: "PortSwigger: XXE via file upload",
            url: "https://portswigger.net/web-security/xxe"
        }
    },
    {
        question: "Как защитить .NET приложение от XXE?",
        answers: [
            "Установить XmlResolver в null или ProhibitDtd/DtdProcessing в Prohibit для безопасного парсинга",
            "Удалить .NET framework с сервера и переписать приложение на другом языке программирования",
            "Использовать C++ для критичных XML операций так как он более безопасен против XXE",
            "Ничего не делать так как .NET имеет built-in защиту от XXE начиная с Framework 2.0",
            "Установить только HTTPS соединения что автоматически защищает от всех XXE векторов атак",
            "Использовать code obfuscation для затруднения reverse engineering уязвимого парсинга",
            "Применить роlle-based access control для ограничения кто может загружать XML документы"
        ],
        correctAnswerIndex: 0,
        explanation: "В .NET для защиты от XXE: установить XmlResolver = null, ProhibitDtd = true (старые версии) или DtdProcessing = DtdProcessing.Prohibit (новые).",
        link: {
            label: "Microsoft: XML Security in .NET",
            url: "https://docs.microsoft.com/en-us/dotnet/standard/security/"
        }
    },
    {
        question: "Является ли `DocumentBuilderFactory.setExpandEntityReferences(false)` защитой в Java?",
        answers: [
            "Да, это одна из настроек для предотвращения XXE но требуются дополнительные меры безопасности",
            "Нет, эта настройка не влияет на безопасность и предназначена только для оптимизации памяти",
            "Это настройка для JSON парсинга не имеющая отношения к безопасности XML обработки",
            "Это для работы с изображениями встроенными в XML как base64 не для защиты от XXE",
            "Функция была удалена из современных версий Java как deprecated и неэффективная для безопасности",
            "Это защищает только от XSS атак в XML теги но не предотвращает XXE уязвимости",
            "Настройка работает только в combination с firewall rules на network уровне инфраструктуры"
        ],
        correctAnswerIndex: 0,
        explanation: "setExpandEntityReferences(false) предотвращает раскрытие entity references, но для полной защиты нужно также отключить DOCTYPE и external entities.",
        link: {
            label: "OWASP: Java XXE Prevention",
            url: "https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html#java"
        }
    },
    {
        question: "Что такое 'Entity Expansion'?",
        answers: [
            "Процесс замены ссылки на сущность её значением при парсинге XML документа парсером",
            "Расширение файлов на диске при записи больших XML документов с глубокой вложенностью",
            "Увеличение физического размера XML сущности при компрессии и архивировании данных",
            "Добавление новых полей в XML схему при эволюции API и расширении функциональности приложения",
            "Процесс разрастания атрибутов entity в базе данных при длительной эксплуатации системы",
            "Автоматическое добавление префиксов namespace ко всем элементам при валидации документа",
            "Процесс конвертации коротких имен тегов в полные qualified names с полными путями"
        ],
        correctAnswerIndex: 0,
        explanation: "Entity Expansion — процесс, при котором парсер заменяет &entity; на её значение. При рекурсивных entities это может привести к экспоненциальному росту (DoS).",
        link: {
            label: "OWASP: Entity Expansion Attack",
            url: "https://owasp.org/www-community/vulnerabilities/XML_Entity_Expansion"
        }
    },
    {
        question: "Какая ошибка часто выдается при Billion Laughs атаке?",
        answers: [
            "Out of Memory / Stack Overflow — исчерпание памяти из-за экспоненциального расширения entities",
            "404 Not Found — стандартная ошибка веб сервера когда запрашиваемый ресурс не найден",
            "403 Forbidden — ошибка доступа когда сервер понимает запрос но отказывается его выполнять",
            "200 OK — успешный HTTP статус код указывающий что запрос был обработан корректно сервером",
            "301 Moved Permanently — перенаправление на новый URL когда ресурс был перемещен навсегда",
            "502 Bad Gateway — ошибка proxy сервера при получении некорректного ответа от upstream сервера",
            "429 Too Many Requests — rate limiting когда клиент отправил слишком много запросов"
        ],
        correctAnswerIndex: 0,
        explanation: "Billion Laughs вызывает экспоненциальное расширение entities, что приводит к исчерпанию памяти (Out of Memory error) или Stack Overflow.",
        link: {
            label: "Wikipedia: Billion laughs attack",
            url: "https://en.wikipedia.org/wiki/Billion_laughs_attack"
        }
    },
    {
        question: "Можно ли эксплуатировать XXE через JSON API?",
        answers: [
            "Обычно нет, если только API не конвертирует JSON в XML внутри или поддерживает XML content-type",
            "Да, всегда можно эксплуатировать XXE так как JSON и XML эквивалентные форматы данных",
            "Нет, никогда невозможно так как JSON и XML используют совершенно разные парсеры",
            "JSON это подмножество XML поэтому XXE атаки автоматически работают через JSON endpoint",
            "Только если JSON содержит escaped XML строки которые десериализуются на сервере",
            "Только в старых версиях JSON парсеров до появления современных security патчей",
            "Только если Content-Type намеренно некорректный что запутывает автоопределение формата"
        ],
        correctAnswerIndex: 0,
        explanation: "JSON API обычно не уязвимы к XXE, но если API принимает и JSON, и XML (content negotiation), или конвертирует JSON→XML внутри, XXE возможен.",
        link: {
            label: "Content Type Confusion",
            url: "https://portswigger.net/web-security/xxe"
        }
    },
    {
        question: "Где находится файл `hosts` в Linux?",
        answers: [
            "/etc/hosts — стандартное расположение файла hosts в Unix-like системах для DNS resolution",
            "/var/hosts — альтернативное расположение в некоторых специфичных дистрибутивах Linux",
            "/bin/hosts — директория для исполняемых файлов не используется для конфигурационных файлов",
            "/tmp/hosts — временная директория где системные файлы никогда не хранятся постоянно",
            "/home/hosts — пользовательская директория не предназначенная для системных конфигураций",
            "/usr/hosts — директория для shared resources но не для критичных системных конфигов",
            "/opt/hosts — директория для optional software packages не для core системных настроек"
        ],
        correctAnswerIndex: 0,
        explanation: "/etc/hosts — стандартный путь к hosts файлу в Linux. Часто читается через XXE для демонстрации file read уязвимости.",
        link: {
            label: "Linux hosts file",
            url: "https://man7.org/linux/man-pages/man5/hosts.5.html"
        }
    },
    {
        question: "Где находится файл `win.ini` в Windows?",
        answers: [
            "C:/windows/win.ini — legacy конфигурационный файл Windows в системной директории",
            "/etc/win.ini — Unix путь не существующий в Windows operating system архитектуре",
            "D:/win.ini — необычное расположение на альтернативном диске не используется системой",
            "/bin/win.ini — Unix-style путь полностью несовместимый с Windows файловой системой",
            "C:/Program Files/win.ini — директория для установленных программ а не системных конфигов",
            "C:/Users/win.ini — пользовательская директория не содержит системные конфигурационные файлы",
            "C:/Windows/System32/win.ini — хотя System32 системная папка win.ini там не располагается"
        ],
        correctAnswerIndex: 0,
        explanation: "C:/windows/win.ini — legacy конфигурационный файл Windows. Часто используется в XXE PoC для демонстрации чтения файлов на Windows серверах.",
        link: {
            label: "Windows win.ini file",
            url: "https://en.wikipedia.org/wiki/INI_file"
        }
    },
    {
        question: "Что такое 'error-based XXE'?",
        answers: [
            "Получение содержимого файла через текст ошибки парсера путем провоцирования parse errors",
            "XXE которое всегда генерирует ошибки и никогда не работает корректно в реальных сценариях",
            "Ошибочное XXE — неправильно сформированный payload не приводящий к успешной эксплуатации",
            "XXE без ошибок которое работает идеально и не оставляет следов в логах сервера",
            "Техника генерации HTTP error codes для bypass WAF используя некорректный XML синтаксис",
            "XXE через механизм error handling в коде приложения эксплуатирующий exception обработчики",
            "Метод тестирования XXE через анализ различных error messages от разных парсеров"
        ],
        correctAnswerIndex: 0,
        explanation: "Error-based XXE — техника извлечения данных через провоцирование ошибок парсера, которые включают содержимое файла в сообщение об ошибке.",
        link: {
            label: "PortSwigger: Exploiting blind XXE to retrieve data via error messages",
            url: "https://portswigger.net/web-security/xxe/blind/lab-xxe-with-data-retrieval-via-error-messages"
        }
    },
    {
        question: "Какой символ используется для разыменования сущности?",
        answers: [
            "& (амперсанд) — специальный символ XML для начала ссылки на entity перед именем сущности",
            "$ (доллар) — символ используемый в переменных shell и template engines но не в XML entities",
            "# (решетка) — символ для комментариев и якорей в URL не для entity references в XML",
            "@ (собака) — символ используемый в email адресах и decorators но не для XML сущностей",
            "% (процент) — используется для parameter entities в DTD но не для general entity references",
            "* (звездочка) — wildcard символ в file patterns не используется для конкретных entity ссылок",
            "^ (карет) — символ для XOR операций и regex начала строки не для XML entity dereferencing"
        ],
        correctAnswerIndex: 0,
        explanation: "Символ & используется для начала entity reference в XML. Например: &xxe; или &lt; (built-in entity для <).",
        link: {
            label: "W3C: Entity References",
            url: "https://www.w3.org/TR/REC-xml/#sec-entity-ref"
        }
    },
    {
        question: "Как завершается ссылка на сущность?",
        answers: [
            "; (точка с запятой) — символ завершения entity reference после имени сущности в XML",
            ". (точка) — символ конца предложения не используется для завершения XML entity references",
            ": (двоеточие) — разделитель в namespace и URL схемах но не терминатор entity reference",
            ", (запятая) — разделитель элементов в списках не используется для завершения сущностей",
            "! (восклицательный знак) — используется в DOCTYPE declarations но не для entity references",
            "? (вопросительный знак) — используется в XML processing instructions не для entities",
            "] (закрывающая скобка) — завершает CDATA sections но не individual entity references"
        ],
        correctAnswerIndex: 0,
        explanation: "Entity reference завершается точкой с запятой (;). Формат: &entityName;",
        link: {
            label: "W3C: Entity References",
            url: "https://www.w3.org/TR/REC-xml/#dt-entref"
        }
    },
    {
        question: "Что такое SAX парсер?",
        answers: [
            "Simple API for XML — событийный парсер обрабатывающий XML последовательно без загрузки в память",
            "Super Awesome XML — маркетинговое название коммерческого XML парсера с расширенными функциями",
            "Simple Ajax XML — библиотека для асинхронной загрузки XML данных в веб приложениях",
            "Standard API XML — универсальный интерфейс для всех XML парсеров независимо от реализации",
            "Secure AJAX XML — защищенный механизм передачи XML через AJAX с built-in XSS protection",
            "Streaming API for XHTML — специализированный парсер для обработки XHTML документов",
            "Sequential Access XML — метод последовательного чтения XML файлов с жесткого диска"
        ],
        correctAnswerIndex: 0,
        explanation: "SAX (Simple API for XML) — событийный (event-driven) парсер. Читает XML последовательно, вызывая callback функции при встрече элементов.",
        link: {
            label: "SAX Parser",
            url: "https://en.wikipedia.org/wiki/Simple_API_for_XML"
        }
    },
    {
        question: "Что такое DOM парсер?",
        answers: [
            "Document Object Model — загружает весь XML в память создавая древовидную структуру для навигации",
            "Direct Object Model — прямое отображение XML элементов в объекты программирования без промежуточных слоев",
            "Data Object Mode — режим обработки данных оптимизированный для больших XML документов",
            "Disk Only Memory — парсер работающий напрямую с диском без загрузки данных в оперативную память",
            "Dynamic Object Mapping — динамическое создание объектов на основе XML schema в runtime",
            "Distributed Object Manager — менеджер для обработки XML в распределенных системах",
            "Declarative Object Marshaller — конвертер XML в strongly-typed объекты для type-safe операций"
        ],
        correctAnswerIndex: 0,
        explanation: "DOM парсер загружает весь XML документ в память, создавая дерево узлов. Более удобен для навигации, но требователен к памяти.",
        link: {
            label: "DOM Parser",
            url: "https://en.wikipedia.org/wiki/Document_Object_Model"
        }
    },
    {
        question: "Какой парсер более уязвим к DoS (Billion Laughs)?",
        answers: [
            "DOM парсер — так как строит полное дерево в памяти и экспоненциальное расширение критично",
            "SAX парсер — событийный подход делает его наиболее уязвимым к рекурсивному расширению сущностей",
            "StAX парсер — pull-based архитектура создает дополнительные векторы для DoS атак через entities",
            "Никакой парсер не уязвим — все современные парсеры имеют встроенную защиту от Billion Laughs",
            "Только кастомные парсеры — стандартные реализации полностью защищены от DoS через entity expansion",
            "JSON парсер — хотя JSON и не поддерживает entities, он vulnerable к аналогичным DoS векторам",
            "HTML5 парсер — специфичная обработка entities в HTML делает его vulnerable к exponential expansion"
        ],
        correctAnswerIndex: 0,
        explanation: "DOM парсер более уязвим к Billion Laughs, так как строит полное дерево в памяти. Экспоненциальное расширение entities быстро исчерпает память.",
        link: {
            label: "Billion Laughs Attack",
            url: "https://en.wikipedia.org/wiki/Billion_laughs_attack"
        }
    },
    {
        question: "Можно ли читать бинарные файлы через XXE?",
        answers: [
            "Сложно, они могут ломать парсер. Лучше использовать кодирование base64 через PHP фильтры или CDATA",
            "Да, легко и без проблем — любые бинарные данные передаются через XXE как есть",
            "Нет, это технически невозможно — XML поддерживает только текстовые данные в UTF encoding",
            "Только картинки в форматах JPEG и PNG — другие бинарные форматы не совместимы с XXE",
            "Только через специальный binary:// wrapper который конвертирует бинарные данные в hex",
            "Возможно только при использовании multipart/form-data Content-Type в HTTP запросе",
            "Только файлы размером менее 1MB — большие бинарные файлы вызывают overflow в парсере"
        ],
        correctAnswerIndex: 0,
        explanation: "Бинарные данные могут содержать невалидные XML символы. Решение: кодировать в base64 через php://filter или CDATA + hex encoding.",
        link: {
            label: "PHP stream filters",
            url: "https://www.php.net/manual/en/filters.convert.php"
        }
    },
    {
        question: "Что делает `expect://id` wrapper в PHP?",
        answers: [
            "Выполняет команду `id` в шелле если установлен PHP модуль expect — приводит к RCE",
            "Ожидает ввода ID пользователя с клавиатуры для интерактивного взаимодействия с приложением",
            "Генерирует уникальный ID для текущей сессии используя криптографически стойкий генератор случайных чисел",
            "Проверяет существование ID в базе данных и возвращает соответствующую запись или null",
            "Создает ожидание асинхронной операции аналогично JavaScript Promise для неблокирующего I/O",
            "Валидирует формат ID согласно заданному regex паттерну и выбрасывает exception при несоответствии",
            "Резервирует ID в distributed lock system для предотвращения race conditions в concurrent операциях"
        ],
        correctAnswerIndex: 0,
        explanation: "expect://command wrapper в PHP выполняет shell команды при установленном expect модуле. Это может привести к RCE через XXE.",
        link: {
            label: "PHP expect wrapper",
            url: "https://www.php.net/manual/en/wrappers.expect.php"
        }
    },
    {
        question: "Является ли валидация по XSD схемой защитой от XXE?",
        answers: [
            "Нет, XSD проверяет структуру но не отключает внешние сущности — требуется отдельная защита",
            "Да, полностью защищает — XSD validation автоматически блокирует все external entities",
            "Только если XSD схема локальная — remote XSD schemas не обеспечивают XXE защиту",
            "XSD это вирус — использование XSD validation автоматически делает систему уязвимой к атакам",
            "Работает только в combination с HTTPS — без SSL сертификатов XSD не защищает от XXE",
            "Защищает только legacy системы — современные приложения требуют альтернативных механизмов",
            "Только для SOAP web services — REST API не получают XXE защиту через XSD validation"
        ],
        correctAnswerIndex: 0,
        explanation: "XSD проверяет структуру XML, но не отключает обработку external entities. Для защиты от XXE нужно отдельно конфигурировать парсер.",
        link: {
            label: "XML Schema",
            url: "https://www.w3.org/XML/Schema"
        }
    },
    {
        question: "В каком разделе OWASP Top 10 (2017) находился XXE?",
        answers: [
            "A4:2017-XML External Entities (XXE) — выделен как отдельная категория уязвимостей",
            "A1: Injection — объединен с другими injection типами в общую категорию атак",
            "A7: XSS — группирован вместе с cross-site скриптинг уязвимостями",
            "A10: Logging — отнесен к проблемам логирования и мониторинга безопасности",
            "XXE не был включен в OWASP Top 10 2017 — появился только в версии 2021",
            "A3: Sensitive Data Exposure — как часть проблем утечки конфиденциальных данных",
            "A2: Broken Authentication — в контексте bypass аутентификации через XML манипуляции"
        ],
        correctAnswerIndex: 0,
        explanation: "В OWASP Top 10 2017 XXE был отдельной категорией A4. Это подчеркивало его серьезность и распространенность в то время.",
        link: {
            label: "OWASP Top 10 2017",
            url: "https://owasp.org/www-project-top-ten/2017/"
        }
    },
    {
        question: "В каком разделе OWASP Top 10 (2021) находится XXE?",
        answers: [
            "A05:2021-Security Misconfiguration — включено туда как часть неправильных конфигураций",
            "A03:2021-Injection — объединено с другими injection типами атак в общую категорию",
            "Выделен отдельно — остается standalone категорией из-за критичности уязвимости",
            "Убран совсем — считается решенной проблемой благодаря secure defaults в парсерах",
            "A01:2021-Broken Access Control — как способ обхода контроля доступа через файлы",
            "A04:2021-Insecure Design — в контексте архитектурных проблем use случаев XML",
            "A08:2021-Software and Data Integrity Failures — как проблема integrity проверок"
        ],
        correctAnswerIndex: 0,
        explanation: "В OWASP Top 10 2021 XXE объединен с A05:2021-Security Misconfiguration, так как обычно возникает из-за неправильных настроек парсеров.",
        link: {
            label: "OWASP Top 10 2021",
            url: "https://owasp.org/Top10/"
        }
    },
    {
        question: "Что такое jar:// протокол?",
        answers: [
            "Java Archive — позволяет читать файлы из JAR/ZIP архивов и может использоваться в XXE",
            "JavaScript Archive — протокол для загрузки JavaScript модулей из архивированных бандлов",
            "JSON Archive — специальный формат для сжатия и архивирования JSON данных",
            "Jump Address Register — низкоуровневый протокол для assembly инструкций в JVM",
            "Just Another Resource — универсальный fallback протокол для неопознанных типов ресурсов",
            "Jailed Application Runtime — протокол для изолированного выполнения untrusted кода в sandbox",
            "Java Asynchronous Runtime — протокол для асинхронной загрузки ресурсов в многопоточных приложениях"
        ],
        correctAnswerIndex: 0,
        explanation: "jar:// протокол в Java позволяет читать файлы из JAR архивов. Может использоваться в XXE: jar:file:///path/file.jar!/entry",
        link: {
            label: "JAR URL Syntax",
            url: "https://docs.oracle.com/javase/7/docs/api/java/net/JarURLConnection.html"
        }
    },
    {
        question: "Можно ли использовать XXE для атаки на NTLM (Windows)?",
        answers: [
            "Да, заставляя сервер обратиться к SMB шаре атакующего через UNC путь для перехвата хеша",
            "Нет, XXE работает только на Linux системах — Windows architecture несовместима с XXE",
            "Только на Linux — NTLM это Linux-специфичный протокол аутентификации",
            "Только через HTTP — SMB протокол полностью изолирован от XXE векторов атак",
            "Возможно только в Active Directory окружении — standalone Windows серверы защищены",
            "Только при наличии Kerberos — NTLM сам по себе не vulnerable к XXE эксплуатации",
            "Только через PowerShell — cmd.exe не поддерживает необходимые XXE команды"
        ],
        correctAnswerIndex: 0,
        explanation: "XXE может заставить Windows сервер подключиться к SMB шаре через UNC путь (<!ENTITY xxe SYSTEM 'file://attacker-ip/share'>), что приведет к NTLM authentication и возможному relay/crack атакам.",
        link: {
            label: "NTLM Relay via XXE",
            url: "https://diablohorn.com/2019/02/05/xxe-to-ntlm-relay/"
        }
    },
    {
        question: "Что вернет `<!ENTITY xxe SYSTEM 'file:///dev/random'>`?",
        answers: [
            "Бесконечный поток случайных данных приводящий к DoS атаке через исчерпание ресурсов",
            "Ошибку парсера — /dev/random это специальный файл не поддерживаемый XML парсерами",
            "Пустую строку — файл существует но не содержит readable контента для XXE",
            "IP адрес сервера — /dev/random содержит network configuration в Linux системах",
            "Системное время — /dev/random это специальный файл содержащий current timestamp",
            "NULL значение — устройства в /dev/ всегда возвращают null при чтении через XML",
            "256-bit random ключ — ровно 32 байта случайных данных единожды при каждом обращении"
        ],
        correctAnswerIndex: 0,
        explanation: "/dev/random — специальный файл-генератор случайных данных. Чтение через XXE может вызвать DoS, так как парсер будет читать бесконечный поток данных.",
        link: {
            label: "Linux /dev/random",
            url: "https://man7.org/linux/man-pages/man4/random.4.html"
        }
    },
    {
        question: "Как проверить слепой XXE, если исходящий трафик блокируется?",
        answers: [
            "По задержкам time-based — например чтение большого файла или /dev/random создаст заметную задержку",
            "Никак — без out-of-band канала blind XXE невозможно детектировать или эксплуатировать",
            "По ошибкам синтаксиса — некорректный XML всегда генерирует специфичные error codes",
            "По цвету пикселей — изменение rendering веб-страницы указывает на successful XXE injection",
            "Через cookie inspection — XXE модифицирует session cookies что можно обнаружить в DevTools",
            "По User-Agent строке — successful XXE добавляет signature в HTTP headers responses",
            "Через Content-Length header — размер ответа коррелирует с success XXE эксплуатации"
        ],
        correctAnswerIndex: 0,
        explanation: "При блокировке out-of-band каналов можно использовать time-based техники: чтение большого файла, /dev/random или медленного ресурса вызовет задержку.",
        link: {
            label: "Time-based XXE",
            url: "https://portswigger.net/web-security/xxe"
        }
    },
    {
        question: "Что безопаснее: `<!DOCTYPE html>` или `<!DOCTYPE foo>`?",
        answers: [
            "HTML5 doctype безопасен не использует DTD. Пользовательские DOCTYPE потенциально опасны в XML",
            "Одинаково безопасны — тип DOCTYPE не влияет на уровень защиты от XXE уязвимостей",
            "Foo безопаснее — custom DOCTYPE автоматически отключает external entity processing",
            "Оба опасны — любой DOCTYPE declaration создает возможность для XXE эксплуатации",
            "HTML DOCTYPE опаснее — встроенные HTML entities увеличивают attack surface для XXE",
            "Зависит от браузера — Chrome обрабатывает DOCTYPE иначе чем Firefox что влияет на безопасность",
            "Foo безопаснее только в production — в development окружении HTML DOCTYPE предпочтителен"
        ],
        correctAnswerIndex: 0,
        explanation: "HTML5 <!DOCTYPE html> не использует DTD и безопасен. Пользовательские DOCTYPE в XML контексте могут включать DTD с external entities.",
        link: {
            label: "HTML5 DOCTYPE",
            url: "https://html.spec.whatwg.org/multipage/syntax.html#the-doctype"
        }
    },
    {
        question: "Какие библиотеки Python уязвимы к XXE (lxml vs defusedxml)?",
        answers: [
            "lxml уязвим по умолчанию если не отключить entities. defusedxml — безопасная альтернатива",
            "Все безопасны — Python 3 автоматически защищает от XXE на interpreter уровне",
            "Все уязвимы — нет безопасных XML парсеров для Python требуется manual hardening",
            "Python не работает с XML — это Java-специфичный формат данных не поддерживаемый в Python",
            "Только lxml2 уязвим — lxml версии 1.x была полностью переписана и защищена",
            "defusedxml уязвим — название misleading это известная backdoor библиотека",
            "Зависит от OS — на Windows обе безопасны на Linux обе уязвимы из-за libc различий"
        ],
        correctAnswerIndex: 0,
        explanation: "lxml уязвим к XXE по умолчанию. defusedxml — обертка с безопасными настройками, блокирующая external entities и DTD.",
        link: {
            label: "defusedxml library",
            url: "https://github.com/tiran/defusedxml"
        }
    },
    {
        question: "Что делает `resolveEntity` в Java?",
        answers: [
            "Метод который можно переопределить для безопасной обработки или блокировки внешних сущностей",
            "Решает математические уравнения встроенные в XML как XPath expressions для вычислений",
            "Удаляет все сущности из XML документа оставляя только чистые текстовые данные",
            "Создает новые сущности динамически на основе runtime параметров приложения",
            "Конвертирует entity references в URL encoded формат для безопасной передачи",
            "Компилирует сущности в bytecode для оптимизации производительности парсинга",
            "Валидирует syntax всех сущностей согласно XML 1.0 specification перед обработкой"
        ],
        correctAnswerIndex: 0,
        explanation: "resolveEntity — callback метод в SAX parser, который можно переопределить для контроля обработки entities. Можно вернуть null для блокировки external entities.",
        link: {
            label: "Java EntityResolver",
            url: "https://docs.oracle.com/javase/7/docs/api/org/xml/sax/EntityResolver.html"
        }
    },
    {
        question: "Можно ли получить RCE через XXE в PHP без `expect`?",
        answers: [
            "Возможно при использовании phar:// wrapper и наличии gadget chains для десериализации",
            "Нет, никогда — без expect модуля RCE через XXE в PHP технически impossible",
            "Всегда возможно — любой XXE автоматически приводит к RCE в PHP приложениях",
            "Только через http:// wrapper — удаленное выполнение кода через HTTP requests",
            "Только в PHP версии 5.x — PHP 7+ полностью защищен от RCE через XXE",
            "Через data:// wrapper — inline code execution в URI scheme обходит все ограничения",
            "Через ftp:// wrapper — FTP протокол позволяет execute commands на remote сервере"
        ],
        correctAnswerIndex: 0,
        explanation: "phar:// wrapper может десериализовать PHP объекты. При наличии подходящего gadget chain это может привести к RCE даже без expect.",
        link: {
            label: "PHAR deserialization",
            url: "https://blog.ripstech.com/2018/new-php-exploitation-technique/"
        }
    },
    {
        question: "Что такое 'Restricted Zones' в IE и как это связано с XXE?",
        answers: [
            "Настройки безопасности влияющие на то куда XML парсер может обращаться за ресурсами",
            "Географические зоны где доступ к интернету ограничен правительственными firewall",
            "Зоны парковки где использование мобильных устройств запрещено законодательно",
            "DNS зоны с ограниченным доступом для internal corporate сетей на уровне resolver",
            "Никак не связано — Internet Explorer не имеет отношения к XXE уязвимостям",
            "Browser cookies с restricted domain scope что ограничивает XXE exploitation",
            "Memory regions изолированные от XXE парсера для предотвращения buffer overflow"
        ],
        correctAnswerIndex: 0,
        explanation: "IE Restricted Zones — security зоны браузера, ограничивающие доступ к файлам/сети. Влияют на то, какие URI схемы может обрабатывать XML парсер.",
        link: {
            label: "IE Security Zones",
            url: "https://docs.microsoft.com/en-us/previous-versions/windows/internet-explorer/ie-developer/platform-apis/ms537183(v=vs.85)"
        }
    },
    {
        question: "Какой порт обычно сканируют при SSRF через XXE для доступа к метаданным облака?",
        answers: [
            "80 для HTTP запроса к http://169.254.169.254 — cloud metadata service endpoint",
            "21 для FTP доступа к файловой системе облачной инфраструктуры провайдера",
            "22 для SSH подключения к internal management интерфейсам облачных серверов",
            "445 для SMB доступа к shared storage ресурсам в облачной виртуальной сети",
            "3389 для RDP доступа к Windows instances через internal cloud networking",
            "3306 для MySQL баз данных размещенных на внутренних облачных database серверах",
            "6379 для Redis cache servers используемых в облачной инфраструктуре для сессий"
        ],
        correctAnswerIndex: 0,
        explanation: "169.254.169.254 (порт 80) — метаданные облачных провайдеров (AWS, Azure, GCP). XXE SSRF может извлекать токены, ключи API, credentials.",
        link: {
            label: "Cloud Metadata Services",
            url: "https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html"
        }
    },
    {
        question: "Что такое RSS фид?",
        answers: [
            "Really Simple Syndication — XML формат для новостей часто являющийся вектором для XXE атак",
            "Remote Script Service — сервис для загрузки JavaScript скриптов с удаленных серверов",
            "Recursive Style System — механизм каскадных стилей с поддержкой рекурсивного наследования",
            "Relational Storage Structure — формат для хранения реляционных данных в файловой системе",
            "Runtime Security Scanner — инструмент для динамического анализа безопасности приложений",
            "Reverse Shell Service — бэкдор для установления обратного соединения с attacker сервером",
            "Random String Seed — генератор случайных строк для криптографических операций"
        ],
        correctAnswerIndex: 0,
        explanation: "RSS (Really Simple Syndication) — XML формат. При обработке RSS фидов на сервере уязвимый парсер может быть эксплуатирован через XXE.",
        link: {
            label: "RSS Specification",
            url: "https://www.rssboard.org/rss-specification"
        }
    },
    {
        question: "Можно ли внедрить XXE через PDF?",
        answers: [
            "Да, PDF может содержать XMP XML метаданные или XFA формы vulnerable к XXE при парсинге",
            "Нет, PDF это полностью бинарный формат несовместимый с XML структурами и XXE",
            "Только в Adobe Reader 5 — новые версии полностью переписаны без XML компонентов",
            "Только в Chrome PDF viewer — другие браузеры используют non-XML rendering engine",
            "Возможно только при конвертации PDF в other форматы но не при прямом открытии",
            "Только encrypted PDF — encryption wrapper использует XML для key management",
            "Только scanned PDF с OCR — текстовый layer хранится в XML формате vulnerable к XXE"
        ],
        correctAnswerIndex: 0,
        explanation: "PDF может содержать XMP (XML Metadata Platform) и XFA (XML Forms Architecture). При обработке на сервере уязвимый XML парсер может быть эксплуатирован.",
        link: {
            label: "XMP Specification",
            url: "https://www.adobe.com/devnet/xmp.html"
        }
    },
    {
        question: "Как влияет `Content-Type: application/xml` на WAF?",
        answers: [
            "WAF может применять XML-специфичные сигнатуры. Смена на text/xml может обойти некоторые правила",
            "WAF всегда блокирует XML независимо от Content-Type для максимальной безопасности",
            "WAF игнорирует XML полностью — фокусируется только на SQL и XSS injection векторах",
            "WAF падает при обработке XML — это known limitation большинства коммерческих решений",
            "Content-Type не влияет — WAF анализирует только URL и query string параметры",
            "WAF автоматически конвертирует XML в JSON для упрощения rule matching процесса",
            "WAF шифрует весь XML трафик дополнительным TLS layer для protection от sniffing"
        ],
        correctAnswerIndex: 0,
        explanation: "WAF может иметь разные правила для application/xml vs text/xml. Смена Content-Type или encoding (UTF-16) может обойти некоторые WAF фильтры.",
        link: {
            label: "WAF Bypass Techniques",
            url: "https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XXE%20Injection#waf-bypass"
        }
    },
    {
        question: "Что такое XXE через локальный DTD?",
        answers: [
            "Техника использования существующего на сервере DTD файла для переопределения сущностей при закрытом external доступе",
            "Использование DTD с USB флешки подключенной к серверу для offline XML validation",
            "Использование DTD из browser cache что позволяет эксплуатировать XXE client-side",
            "Такого термина не существует — все DTD либо internal inline либо external remote",
            "DTD stored в localStorage браузера для persistent XXE exploitation across sessions",
            "Техника использования DTD из /tmp директории создаваемого previous requests",
            "DTD генерируемый runtime на основе environment variables сервера"
        ],
        correctAnswerIndex: 0,
        explanation: "Локальный DTD — техника использования DTD файлов, уже существующих на сервере (например, /usr/share/yelp/dtd/) для переопределения parameter entities когда external доступ закрыт.",
        link: {
            label: "Local DTD Exploitation",
            url: "https://mohemiv.com/all/exploiting-xxe-with-local-dtd-files/"
        }
    },
    {
        question: "Где часто лежат DTD файлы в Linux?",
        answers: [
            "/usr/share/yelp/dtd/docbookx.dtd — стандартный путь Gnome DOCBOOK DTD файлов",
            "/etc/dtd — стандартная системная директория для всех DTD конфигурационных файлов",
            "/var/dtd — runtime директория где приложения создают temporary DTD файлы",
            "/home/dtd — пользовательская директория для хранения custom DTD определений",
            "/opt/dtd — optional software директория где third-party приложения хранят DTD",
            "/lib/dtd — библиотечная директория для shared DTD files используемых multiple программами",
            "/tmp/dtd — временная директория куда парсеры кэшируют downloaded remote DTD файлы"
        ],
        correctAnswerIndex: 0,
        explanation: "В Linux часто можно найти DTD в /usr/share/yelp/dtd/ (GNOME), /usr/share/xml/, /usr/share/sgml/. Используются в техниках local DTD exploitation.",
        link: {
            label: "Local DTD Files",
            url: "https://github.com/GoSecure/dtd-finder"
        }
    },
    {
        question: "Какие файлы конфигурации WEB-серверов используют XML?",
        answers: [
            "web.xml (Java/Tomcat), applicationContext.xml (Spring), web.config (.NET/IIS) — XML конфигурации",
            "httpd.conf — Apache конфигурация использующая XML синтаксис для директив",
            "nginx.conf — Nginx конфигурация в XML формате для web server настроек",
            ".htaccess — Apache per-directory XML конфигурация для override server settings",
            "php.ini — PHP конфигурация в XML формате определяющая runtime настройки",
            "my.cnf — MySQL конфигурация которая использует XML для database параметров",
            "redis.conf — Redis конфигурация в XML формате для cache server настроек"
        ],
        correctAnswerIndex: 0,
        explanation: "Многие Java (web.xml, Spring beans), .NET (web.config) приложения используют XML для конфигурации. Эти файлы могут быть vulnerable если парсятся с external input.",
        link: {
            label: "Java web.xml",
            url: "https://docs.oracle.com/cd/E13222_01/wls/docs81/webapp/web_xml.html"
        }
    },
    {
        question: "Можно ли использовать XXE для чтения исходного кода файлов приложения?",
        answers: [
            "Да, через чтение PHP/JSP/ASPX файлов если есть доступ к файловой системе и известны пути",
            "Нет, исходный код автоматически компилируется и недоступен для чтения через XXE атаки",
            "Только скомпилированные бинарные файлы доступны — source code полностью защищен",
            "Возможно только для JavaScript файлов — серверный код недоступен через XXE exploitation",
            "Только в development окружении — production код защищен через obfuscation и minification",
            "Только CSS файлы могут быть прочитаны — логика приложения недоступна для XXE",
            "Только HTML templates доступны — backend code на Python/Ruby/Go полностью изолирован"
        ],
        correctAnswerIndex: 0,
        explanation: "XXE позволяет читать любые файлы, включая исходный код (PHP, JSP, ASPX). Можно использовать base64 encoding для бинарных или проблемных файлов.",
        link: {
            label: "XXE File Read",
            url: "https://portswigger.net/web-security/xxe"
        }
    },
    {
        question: "Какой header может указывать на XML processing?",
        answers: [
            "Content-Type: application/xml, text/xml, application/soap+xml — указывают на XML формат данных",
            "Content-Type: application/json — всегда указывает на JSON без примесей XML в payload",
            "Accept: text/html — клиент ожидает HTML response что предполагает XML обработку",
            "User-Agent: Mozilla/5.0 — информация о браузере указывает на XML capabilities клиента",
            "Authorization: Bearer — JWT токены содержат XML claims требующие парсинга на сервере",
            "Cookie: session_id — cookies всегда хранятся в XML формате в backend storage",
            "Cache-Control: no-cache — управление кэшированием связано с XML document validity"
        ],
        correctAnswerIndex: 0,
        explanation: "Content-Type headers вроде application/xml, text/xml, application/soap+xml указывают, что payload в XML формате и будет парситься.",
        link: {
            label: "MIME Types",
            url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types"
        }
    },
    {
        question: "Что такое XXE Billion Laughs с вложенными parameter entities?",
        answers: [
            "Усложненная DoS атака через рекурсивные parameter entities в external DTD для обхода ограничений",
            "Легковесная техника тестирования производительности для benchmark XML парсеров",
            "Метод оптимизации XML parsing через caching часто используемых entity definitions",
            "Comedian technique — использование юмористических имен entity для confusion анализаторов безопасности",
            "Deprecated attack известный только в теории не work в современных XML парсерах",
            "Social engineering атака через отправку забавных XML документов для distraction security team",
            "Compression technique для уменьшения размера XML через entity reuse и деduplications"
        ],
        correctAnswerIndex: 0,
        explanation: "Parameter entities в external DTD могут обойти некоторые защиты. Позволяют создать экспоненциальное расширение даже при запрете inline entities.",
        link: {
            label: "Billion Laughs Variants",
            url: "https://en.wikipedia.org/wiki/Billion_laughs_attack"
        }
    },
    {
        question: "Как выглядит простой XXE payload для чтения /etc/passwd?",
        answers: [
            "<?xml version='1.0'?><!DOCTYPE root [<!ENTITY xxe SYSTEM 'file:///etc/passwd'>]><root>&xxe;</root>",
            "<xml><file>/etc/passwd</file></xml> — простой тег с путем к файлу для автоматического чтения",
            "<read file='/etc/passwd'/> — специальный самозакрывающийся тег для file operations в XML",
            "{\"xxe\": \"file:///etc/passwd\"} — JSON payload который конвертируется в XXE на сервере",
            "<script>document.read('/etc/passwd')</script> — JavaScript для client-side file access через XML",
            "<include src='/etc/passwd'/> — HTML5 include директива для встраивания файлов в XML",
            "ENTITY=file:///etc/passwd — query parameter который парсится как XXE vector на backend"
        ],
        correctAnswerIndex: 0,
        explanation: "Базовый XXE payload: объявить DOCTYPE с ENTITY, определить SYSTEM файл, использовать &xxe; для reference.",
        link: {
            label: "XXE Payload Examples",
            url: "https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XXE%20Injection"
        }
    },
    {
        question: "Можно ли комбинировать XXE с SQL Injection?",
        answers: [
            "Теоретически да: читать DB config files через XXE затем использовать credentials для SQL Injection",
            "Нет, это взаимоисключающие техники — нельзя использовать одновременно в одной атаке",
            "Всегда обязательно — XXE не работает без предварительного SQL Injection для setup",
            "Только в NoSQL базах данных — реляционные БД несовместимы с комбинированными атаками",
            "Только через GraphQL — стандартные REST API не поддерживают такие chain атаки",
            "Только in-memory databases вроде Redis — persistent storage защищен от combo exploits",
            "Комбинация автоматически блокируется WAF — невозможна даже теоретически в production"
        ],
        correctAnswerIndex: 0,
        explanation: "XXE можно комбинировать с другими атаками: читать DB configs/credentials через XXE, затем использовать их для SQL Injection или других векторов.",
        link: {
            label: "Attack Chaining",
            url: "https://owasp.org/www-community/attacks/"
        }
    },
    {
        question: "Что такое 'gopher://' protocol?",
        answers: [
            "Устаревший протокол позволяющий формировать произвольные TCP пакеты полезный для SSRF через XXE",
            "Современный протокол для высокоскоростной передачи больших файлов в распределенных системах",
            "Протокол для peer-to-peer обмена данными похожий на BitTorrent но для XML документов",
            "Зоологический термин не имеющий отношения к компьютерным сетям и протоколам передачи",
            "Google'sopher — внутренний протокол Google для индексирования web-страниц crawlers",
            "Gaming protocol — используется в онлайн играх для синхронизации состояния между клиентами",
            "Graphics protocol — для передачи векторной графики между design приложениями в real-time"
        ],
        correctAnswerIndex: 0,
        explanation: "gopher:// — старый протокол, позволяющий создавать произвольные TCP запросы. Используется в SSRF через XXE для атак на внутренние сервисы (Redis, memcached).",
        link: {
            label: "Gopher Protocol in SSRF",
            url: "https://book.hacktricks.xyz/pentesting-web/ssrf-server-side-request-forgery#gopher"
        }
    },
    {
        question: "Является ли HTTP Basic Authentication защитой в cloud metadata endpoint?",
        answers: [
            "Нет, метаданные обычно доступны без аутентификации если запрос идет с internal IP сервера",
            "Да, полностью защищает — требуется username и password для доступа к любым metadata",
            "Только с 2FA — single factor authentication недостаточен для cloud metadata защиты",
            "Защита работает только для AWS — Azure и GCP не require authentication вообще",
            "Только OAuth 2.0 защищает — Basic Auth deprecated для cloud metadata services",
            "Metadata endpoint не существует — это миф распространенный в security community",
            "Защита применяется автоматически — невозможно получить metadata без proper credentials"
        ],
        correctAnswerIndex: 0,
        explanation: "Cloud metadata endpoints (169.254.169.254) обычно не требуют аутентификации, полагаясь на network isolation. XXE SSRF обходит эту защиту.",
        link: {
            label: "AWS Metadata",
            url: "https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html"
        }
    },
    {
        question: "Можно ли использовать UTF-16 encoding для обхода WAF при XXE?",
        answers: [
            "Да, смена кодировки на UTF-16 может обойти WAF сигнатуры настроенные только на UTF-8",
            "Нет, UTF-16 полностью несовместим с XML и приведет к parse errors в любом парсере",
            "Только UTF-32 работает — UTF-16 deprecated в современных XML спецификациях W3C",
            "WAF автоматически декодирует все кодировки — bypass через encoding технически impossible",
            "Только ASCII encoding поддерживается в XML — Unicode варианты вызывают исключения парсера",
            "UTF-16 работает только в Internet Explorer — другие браузеры блокируют non-UTF-8 XML",
            "UTF-16 это video codec не имеющий отношения к text кодировкам в XML документах"
        ],
        correctAnswerIndex: 0,
        explanation: "WAF может не детектировать XXE payload в UTF-16. XML поддерживает UTF-16, поэтому смена encoding может обойти signature-based фильтры.",
        link: {
            label: "XML Character Encoding",
            url: "https://www.w3.org/TR/REC-xml/#charencoding"
        }
    },
    {
        question: "Что такое 'XXE via XInclude'?",
        answers: [
            "Техника инъекции XXE в data value когда вы не контролируете DOCTYPE но данные вставляются в XML",
            "Включение JavaScript файлов в XML для выполнения на клиенте аналогично script tags",
            "CSS @include directive для XML styling при rendering документов в браузере",
            "C/C++ #include препроцессор директива портированная в XML спецификацию для модульности",
            "PHP include() функция адаптированная для server-side XML template processing",
            "Server-side include механизм Apache HTTPd работающий с XML документами",
            "SQL INCLUDE clause для встраивания query results в XML output формат"
        ],
        correctAnswerIndex: 0,
        explanation: "Когда DOCTYPE недоступен, но ваши данные вставляются в XML, можно использовать XInclude: <xi:include href='file:///etc/passwd'/>",
        link: {
            label: "XInclude Injection",
            url: "https://portswigger.net/web-security/xxe/lab-xinclude-attack"
        }
    },
    {
        question: "В каких форматах документов часто встречается XML?",
        answers: [
            "DOCX, XLSX, PPTX, SVG, RSS, SOAP — все используют XML как базовый или компонентный формат",
            "MP3, MP4, AVI — мультимедийные файлы используют XML для хранения audio/video tracks",
            "JPG, PNG, GIF — графические форматы основаны на XML для описания пикселей изображения",
            "EXE, DLL, SO — исполняемые файлы содержат XML манифесты для dependencies resolution",
            "Только TXT файлы — plain text это единственный формат совместимый с XML структурами",
            "ZIP, RAR, 7Z — архиваторы используют XML для описания содержимого compressed архивов",
            "ISO, VMDK, VHD — образы дисков хранят filesystem metadata в XML формате"
        ],
        correctAnswerIndex: 0,
        explanation: "Office форматы (DOCX, XLSX, PPTX), SVG, RSS, SOAP, SAML, многие конфиги используют XML. Это расширяет attack surface для XXE.",
        link: {
            label: "Office Open XML",
            url: "https://en.wikipedia.org/wiki/Office_Open_XML"
        }
    },
    {
        question: "Может ли XXE эксплуатироваться через HTTP headers?",
        answers: [
            "Редко, но если header значение парсится как XML (например SOAP в заголовках) возможна эксплуатация",
            "Всегда — любой HTTP header автоматически парсится как XML современными web серверами",
            "Никогда — HTTP headers это plain text полностью несовместимый с XML структурами",
            "Только Cookie header — cookies специально designed для XML serialization в backend",
            "Только Authorization header — JWT tokens содержат XML который парсится при валидации",
            "Только User-Agent — браузеры отправляют XML capabilities в этом header для content negotiation",
            "Только Referer header — URL могут содержать XML-encoded данные требующие парсинга"
        ],
        correctAnswerIndex: 0,
        explanation: "Если приложение парсит header значения как XML (редко, но бывает в custom SOAP implementations), возможна XXE эксплуатация через headers.",
        link: {
            label: "XXE Attack Vectors",
            url: "https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing"
        }
    },
    {
        question: "Поможет ли HTTPS защитить от XXE?",
        answers: [
            "Нет, HTTPS шифрует транспорт но не защищает от логических уязвимостей вроде XXE парсинга",
            "Да, полностью — SSL сертификаты автоматически validate XML content и блокируют external entities",
            "Частично — HTTPS предотвращает XXE на клиенте но не на server-side processing",
            "Только с HSTS — без Strict-Transport-Security header HTTPS не защищает от XXE",
            "Только TLS 1.3 — старые версии SSL/TLS protocols уязвимы к XXE через protocol downgrade",
            "HTTPS защищает только metadata — actual XML content остается vulnerable к XXE vectors",
            "Только с client certificates — односторонний TLS недостаточен для XXE prevention"
        ],
        correctAnswerIndex: 0,
        explanation: "HTTPS защищает транспортный уровень, но не помогает против XXE, которая является логической уязвимостью обработки XML на сервере.",
        link: {
            label: "HTTPS vs Application Security",
            url: "https://owasp.org/www-community/Transport_Layer_Protection_Cheat_Sheet"
        }
    },
    {
        question: "Какой самый эффективный способ защиты от XXE?",
        answers: [
            "Отключить DTD processing и external entities в конфигурации парсера полностью запретив их загрузку",
            "Использовать антивирус на сервере для детекции вредоносных XML документов в реальном времени",
            "Применить input length ограничение — XML файлы больше 1KB блокировать как потенциально опасные",
            "Использовать только GET запросы — POST с XML payload более vulnerable к XXE атакам",
            "Установить Windows Firewall — блокировать все исходящие соединения для prevent SSRF через XXE",
            "Code obfuscation — запутать логику парсинга чтобы атакующий не смог найти уязвимости",
            "Переименовать /etc/passwd — если файл недоступен по стандартному пути XXE не сработает"
        ],
        correctAnswerIndex: 0,
        explanation: "Лучшая защита: полностью отключить DTD processing и external entities в парсере. Также можно использовать less complex форматы вроде JSON.",
        link: {
            label: "XXE Prevention",
            url: "https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html"
        }
    },
    {
        question: "Можно ли детектировать XXE через мониторинг сетевого трафика?",
        answers: [
            "Частично: можно детектировать OOB XXE по исходящим DNS/HTTP запросам к подозрительным доменам",
            "Полностью — любой XXE payload создает unique network signature детектируемую IDS системами",
            "Невозможно — XXE работает полностью offline без создания network активности вообще",
            "Только через deep packet inspection SSL трафика — unencrypted connections не показывают XXE",
            "Network monitoring бесполезен — XXE это application layer атака invisible для network tools",
            "Только в IPv6 сетях — IPv4 протокол не содержит достаточно метаданных для XXE detection",
            "Только через NetFlow — packet capture слишком медленный для real-time XXE detection"
        ],
        correctAnswerIndex: 0,
        explanation: "OOB XXE создает DNS или HTTP запросы к внешним доменам. Мониторинг необычных исходящих подключений может детектировать эту активность.",
        link: {
            label: "XXE Detection",
            url: "https://portswigger.net/web-security/xxe"
        }
    },
    {
        question: "Что такое 'StAX' парсер?",
        answers: [
            "Streaming API for XML — pull-based парсер читающий XML последовательно с control flow у приложения",
            "Static Analysis for XML — инструмент для статического анализа безопасности XML документов",
            "Stack Allocation XML — парсер использующий stack memory для эффективной работы с большими файлами",
            "Standard API for XHTML — универсальный интерфейс для парсинга XHTML в веб приложениях",
            "Secure Transmission API XML — защищенный протокол для encrypted XML data обмена",
            "Synchronized Threading API XML — multi-threaded парсер для параллельной обработки XML",
            "Stateless API for XMLHttpRequest — клиентская библиотека для AJAX запросов с XML response"
        ],
        correctAnswerIndex: 0,
        explanation: "StAX (Streaming API for XML) — pull-based парсер. В отличие от SAX (push), приложение контролирует когда читать следующий элемент.",
        link: {
            label: "StAX Parser",
            url: "https://docs.oracle.com/javase/tutorial/jaxp/stax/index.html"
        }
    },
    {
        question: "Может ли XXE работать через WebSockets?",
        answers: [
            "Да, если WebSocket сообщения содержат XML и обрабатываются уязвимым парсером на сервере",
            "Нет, WebSocket это binary protocol полностью incompатible с текстовыми XML данными",
            "Только через wss:// — незашифрованные ws:// соединения не поддерживают XML transport",
            "WebSockets deprecated — современные приложения используют HTTP/2 вместо WebSocket протокола",
            "Только для real-time gaming — другие use cases WebSocket не vulnerable к XXE",
            "Только через Socket.IO wrapper — нативные WebSocket API не поддерживают XML messages",
            "WebSocket это hardware component — software протокол не имеет отношения к XXE атакам"
        ],
        correctAnswerIndex: 0,
        explanation: "Если WebSocket передает XML данные, которые парсятся на сервере уязвимым парсером, XXE возможен. Протокол транспорта не важен.",
        link: {
            label: "WebSocket Security",
            url: "https://owasp.org/www-community/attacks/WebSocket_Attacks"
        }
    },
    {
        question: "Что такое XML Bomb?",
        answers: [
            "Другое название DoS атаки через экспоненциальное расширение entities (Billion Laughs Attack)",
            "Вредоносный JavaScript код встроенный в XML для выполнения на клиенте при рендеринге",
            "Физическое устройство использующее XML для программирования детонации взрывчатки",
            "SQL Injection payload специально закодированный в XML формат для обхода валидации",
            "XML файл больше 1GB который crash приложение из-за недостатка дискового пространства",
            "Zero-day уязвимость в XML 1.0 спецификации позволяющая arbitrary code execution",
            "Backdoor в libxml2 библиотеке установленный китайскими хакерами для espionage"
        ],
        correctAnswerIndex: 0,
        explanation: "XML Bomb — синоним Billion Laughs. DoS атака через рекурсивные entity definitions, вызывающие экспоненциальный рост при парсинге.",
        link: {
            label: "XML Bomb",
            url: "https://en.wikipedia.org/wiki/Billion_laughs_attack"
        }
    },
    {
        question: "Поможет ли rate limiting защититься от XXE?",
        answers: [
            "Не от самой XXE но может ограничить  DoS через Billion Laughs или замедлить автоматизированное сканирование",
            "Полностью решает проблему — rate limiting это основной recommended метод XXE prevention",
            "Делает ситуацию хуже — rate limiting конфликтует с XML parsing и вызывает deadlocks",
            "Работает только для blind XXE — classic in-band XXE полностью bypass rate limiting",
            "Только в production — development окружение не поддерживает rate limiting для XXE",
            "Rate limiting это миф — не существует в реальных web frameworks только в теории",
            "Только hardware rate limiters — software implementations не эффективны против XXE"
        ],
        correctAnswerIndex: 0,
        explanation: "Rate limiting не защищает от XXE напрямую, но может ограничить DoS атаки и затруднить автоматизированное тестирование на XXE.",
        link: {
            label: "Rate Limiting",
            url: "https://owasp.org/www-community/controls/Blocking_Brute_Force_Attacks"
        }
    },
    {
        question: "Какие CVE связаны с XXE в популярных библиотеках?",
        answers: [
            "Множество: CVE для Apache Xerces, libxml2, .NET Framework и других парсеров с небезопасными defaults",
            "Ноль — XXE это теоретическая уязвимость никогда не встречающаяся в реальных системах",
            "Только один CVE-2000-1234 — первая и последняя XXE уязвимость обнаруженная в истории",
            "CVE система не покрывает XXE — это не считается официальной уязвимостью требующей CVE",
            "Все CVE секретны — информация об XXE уязвимостях classified governments по всему миру",
            "Только в Internet Explorer — другие браузеры никогда не имели XXE уязвимостей с CVE",
            "CVE assigned только для hardware — software уязвимости вроде XXE используют другие системы"
        ],
        correctAnswerIndex: 0,
        explanation: "Существует множество CVE для XXE в различных библиотеках: Apache Xerces, libxml2, JAXB, .NET и других, где небезопасные настройки по умолчанию приводили к XXE.",
        link: {
            label: "XXE CVEs",
            url: "https://cve.mitre.org/cgi-bin/cvekey.cgi?keyword=xxe"
        }
    },
    {
        question: "Как называется техника чтения внутренних DTD для их переопределения?",
        answers: [
            "Local DTD Exploitation — использование существующих DTD файлов на сервере для parameter entity tricks",
            "Internal DTD Hijacking — захват control над встроенными DTD через man-in-the-middle атаки",
            "DTD Cache Poisoning — модификация кэшированных DTD для persistent backdoor установки",
            "Inline DTD Override — переопределение DTD непосредственно в XML document через special syntax",
            "DTD Reflection Attack — отражение DTD definitions обратно к серверу для amplification",
            "Recursive DTD Inclusion — вложенные DTD файлы создающие circular dependencies для DoS",
            "DTD Schema Manipulation — модификация XSD схем для bypass validation механизмов"
        ],
        correctAnswerIndex: 0,
        explanation: "Local DTD Exploitation — продвинутая техника использования DTD файлов, уже присутствующих на сервере, для переопределения parameter entities когда external доступ ограничен.",
        link: {
            label: "Local DTD Attacks",
            url: "https://mohemiv.com/all/exploiting-xxe-with-local-dtd-files/"
        }
    },
    {
        question: "Можно ли автоматизировать поиск XXE с помощью Burp Scanner?",
        answers: [
            "Да, Burp Suite Professional имеет встроенные active scan чеки для автоматической детекции XXE",
            "Нет, XXE слишком сложная уязвимость — требуется только ручное тестирование экспертами",
            "Только Burp Community Edition — Professional версия не поддерживает XXE scanning",
            "Burp Scanner это миф — Burp Suite только proxy инструмент без scanning возможностей",
            "Автоматизация невозможна — каждый случай XXE unique требует custom payload crafting",
            "Только через third-party extensions — core Burp функциональность не включает XXE detection",
            "Burp работает только с HTTPS — HTTP endpoints не могут быть scanned на XXE уязвимости"
        ],
        correctAnswerIndex: 0,
        explanation: "Burp Suite Professional Scanner автоматически тестирует на XXE, отправляя различные payloads и анализируя ответы, включая OOB  detection через Collaborator.",
        link: {
            label: "Burp Scanner",
            url: "https://portswigger.net/burp/documentation/scanner"
        }
    },
    {
        question: "Что происходит при попытке читать директорию вместо файла через XXE?",
        answers: [
            "Зависит от парсера: некоторые возвращают ошибку, Java может показать листинг в некоторых случаях",
            "Всегда success — автоматически читается первый файл в директории по алфавиту",
            "Мгновенный crash сервера — попытка чтения директории вызывает kernel panic в Linux",
            "Recursive read всех файлов — полное дерево директории автоматически включается в результат",
            "Silent skip — парсер игнорирует директории и продолжает обработку без errors или warnings",
            "Automatic ZIP — содержимое директории архивируется и возвращается как base64 encoded archive",
            "Permission escalation — чтение /etc/ directory автоматически дает root привилегии процессу"
        ],
        correctAnswerIndex: 0,
        explanation: "Поведение зависит от парсера и ОС. Некоторые Java парсеры (с netdoc://) могли показывать листинг. Обычно возвращается ошибка или пустой результат.",
        link: {
            label: "XXE Directory Listing",
            url: "https://mohemiv.com/all/exploiting-xxe-with-local-dtd-files/"
        }
    },
    {
        question: "Является ли XML signature (XML-DSig) защитой от XXE?",
        answers: [
            "Нет, XML Signature обеспечивает integrity и authenticity но не защищает от XXE при парсинге",
            "Да, полностью — цифровая подпись автоматически валидирует безопасность всего XML контента",
            "Частично — подпись защищает entities но не DOCTYPE declarations от XXE эксплуатации",
            "XML-DSig deprecated — заменен на JSON Web Signature для всех modern приложений",
            "Только при использовании RSA 4096-bit ключей — меньшие размеры ключей не защищают от XXE",
            "Signature это backdoor — использование XML-DSig автоматически создает XXE уязвимости",
            "Работает только offline — в online режиме signature verification bypass возможен через XXE"
        ],
        correctAnswerIndex: 0,
        explanation: "XML Signature проверяет целостность и аутентичность данных, но парсер все равно обрабатывает external entities при парсинге signed документа, сохраняя XXE риск.",
        link: {
            label: "XML Signature",
            url: "https://www.w3.org/TR/xmldsig-core/"
        }
    },
    {
        question: "Что важнее для тестирования на XXE: black-box или white-box подход?",
        answers: [
            "Комбинация: black-box для поиска endpoints, white-box для анализа парсера конфигурации и кода",
            "Только black-box — white-box testing раскрывает слишком много информации делая атаку легче",
            "Только white-box — black-box невозможен для XXE так как payload не виден в responses",
            "Ни то ни другое — XXE требует purple-box подхода смешивающего оба метода одновременно",
            "Gray-box обязателен — середина между black и white единственный effective способ для XXE",
            "Testing бесполезен — XXE можно найти только через production incidents и post-mortems",
            "Automated tools only — ручное тестирование deprecated для современных XXE уязвимостей"
        ],
        correctAnswerIndex: 0,
        explanation: "Лучше комбинировать: black-box для обнаружения XML endpoints и тестирования, white-box для анализа конфигурации парсеров и понимания кодовой базы.",
        link: {
            label: "Testing Approaches",
            url: "https://owasp.org/www-community/Vulnerability_Scanning_Tools"
        }
    }
];
