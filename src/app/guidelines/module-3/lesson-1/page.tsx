
'use client';

import * as React from 'react';
import { ContentPageLayout, P, H2, H3, Ul } from '@/components/content/ContentPageLayout';
import { CodeBlock } from '@/components/content/CodeBlock';
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@/components/ui/card';
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table";
import Link from 'next/link';
import { cn } from '@/lib/utils';
import { FlaskConical, CheckCircle2, XCircle, ScrollText, BookOpen, KeyRound } from 'lucide-react';

const LinkStyle = "text-primary hover:text-primary/80 hover:underline";

const sourcesData = [
  { id: 1, text: "WAHH2 (предполагаемый источник)" },
  { id: 2, text: "A07 Identification and Authentication Failures - OWASP Top 10:2021", url: "https://owasp.org/Top10/A07_2021-Identification_and_Authentication_Failures/" },
  { id: 3, text: "A01 Broken Access Control - OWASP Top 10:2021", url: "https://owasp.org/Top10/A01_2021-Broken_Access_Control/" },
  { id: 4, text: "Broken Authentication: Impact, Examples, and How to Fix It - Bright Security", url: "https://www.brightsec.com/blog/broken-authentication-impact-examples-and-how-to-fix-it/" },
  { id: 6, text: "Identification and Authentication Failures — and How to Prevent Them | Cyolo", url: "https://cyolo.io/blog/identification-and-authentication-failures-and-how-to-prevent-them" },
  { id: 7, text: "Brute-forcing logins with Burp Suite - PortSwigger", url: "https://portswigger.net/burp/documentation/desktop/testing-workflow/authentication-mechanisms/brute-forcing-logins" },
  { id: 9, text: "Using Burp to Brute Force a Login Page - PortSwigger", url: "https://portswigger.net/support/using-burp-to-brute-force-a-login-page" },
  { id: 10, text: "User Enumeration Explained: Techniques and Prevention Tips | Rapid7 Blog", url: "https://www.rapid7.com/blog/post/2017/06/15/about-user-enumeration/" },
  { id: 12, text: "Authentication - OWASP Cheat Sheet Series", url: "https://cheatsheetseries.owasp.org/cheatsheets/Authentication_Cheat_Sheet.html" },
  { id: 13, text: "Forgot Password - OWASP Cheat Sheet Series", url: "https://cheatsheetseries.owasp.org/cheatsheets/Forgot_Password_Cheat_Sheet.html" },
  { id: 14, text: "Forgot Password Cheat Sheet - OWASP (GitHub)", url: "https://github.com/OWASP/www-projectchapter-example/blob/main/cheatsheets/Forgot_Password_Cheat_Sheet.md" },
  { id: 16, text: "Broken Authentication · Pwning OWASP Juice Shop", url: "https://help.owasp-juice.shop/part2/broken-authentication.html" },
  { id: 17, text: "Challenge solutions · Pwning OWASP Juice Shop", url: "https://help.owasp-juice.shop/appendix/solutions.html" },
  { id: 18, text: "Remember-Me Authentication :: Spring Security", url: "https://docs.spring.io/spring-security/reference/servlet/authentication/rememberme.html" },
  { id: 20, text: "Understanding 'Failed Open' and 'Fail Closed' in Software Engineering | AuthZed.com", url: "https://authzed.com/blog/fail-open" },
  { id: 22, text: "What is Fail Open? - Glossary - Training Camp", url: "https://trainingcamp.com/glossary/fail-open/" },
  { id: 23, text: "password_hash - Manual - PHP", url: "https://www.php.net/manual/en/function.password-hash.php" },
  { id: 24, text: "Hashing Passwords in Python with BCrypt - Tutorialspoint", url: "https://www.tutorialspoint.com/hashing-passwords-in-python-with-bcrypt" },
  { id: 25, text: "Password Storage Cheat Sheet - OWASP", url: "https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html" },
  { id: 26, text: "Example of password hashing and verification with password_hash and password_verify - GitHub Gist", url: "https://gist.github.com/jeremykendall/8158884" },
];

const quizQuestions = [
    { question: "Какова основная цель злоумышленника при проведении атаки User Enumeration?", answers: ["Получить доступ к учетной записи администратора.", "Вызвать отказ в обслуживании (DoS).", "Получить список действительных имен пользователей для дальнейших атак.", "Украсть cookie сессии."], correctAnswerIndex: 2 },
    { question: "Что делает 'соль' (salt) при хешировании паролей?", answers: ["Увеличивает скорость хеширования.", "Делает хеш короче.", "Защищает от атак с использованием радужных таблиц.", "Шифрует пароль перед хешированием."], correctAnswerIndex: 2 },
    { question: "Приложение, которое предоставляет пользователю доступ при временном сбое в работе базы данных аутентификации, демонстрирует какую уязвимость?", answers: ["SQL-инъекция.", "Fail-Open.", "Fail-Closed.", "Cross-Site Scripting (XSS)."], correctAnswerIndex: 1 },
    { question: "Почему использование 'девичьей фамилии матери' в качестве вопроса для восстановления пароля является плохой практикой согласно OWASP?", answers: ["Ответ слишком длинный для ввода.", "Ответ часто можно найти в открытых источниках (OSINT).", "Система не может правильно хешировать такой ответ.", "Пользователи часто забывают правильный ответ."], correctAnswerIndex: 1 },
    { question: "Какой тип атаки в Burp Intruder лучше всего подходит для ситуации, когда у вас есть список имен пользователей и отдельный список паролей, и вы хотите проверить все возможные комбинации?", answers: ["Sniper", "Battering Ram", "Pitchfork", "Cluster Bomb"], correctAnswerIndex: 3 },
    { question: "Какая функция в PHP позволяет безопасно обновить хеш пароля пользователя до более современного стандарта без его участия?", answers: ["update_hash()", "password_needs_rehash()", "md5()", "crypt()"], correctAnswerIndex: 1 },
    { question: "Что является наиболее надежным методом защиты от атак credential stuffing?", answers: ["Очень сложная политика паролей.", "Использование CAPTCHA.", "Многофакторная аутентификация (MFA).", "Блокировка учетной записи после 3 неудачных попыток."], correctAnswerIndex: 2 },
    { question: "Какой тип атаки в Burp Intruder наиболее эффективен для тестирования заранее известного списка пар 'имя пользователя:пароль'?", answers: ["Sniper", "Battering Ram", "Pitchfork", "Cluster Bomb"], correctAnswerIndex: 2 },
    { question: "Какова основная цель атаки 'Credential Stuffing'?", answers: ["Перебор всех возможных комбинаций пароля для одного пользователя.", "Использование утекших учетных данных с одного сайта для попытки входа на других сайтах.", "Угадывание пароля на основе личной информации пользователя.", "Изменение пароля пользователя без его ведома."], correctAnswerIndex: 1 },
    { question: "Какой тип атаки в Burp Intruder использует один список полезной нагрузки и одновременно подставляет одно и то же значение во все отмеченные позиции?", answers: ["Sniper", "Battering ram", "Pitchfork", "Cluster Bomb"], correctAnswerIndex: 1 },
    { question: "Веб-приложение отвечает 'Неверное имя пользователя' для несуществующих пользователей и 'Неверный пароль' для существующих. Это пример какой уязвимости?", answers: ["SQL-инъекция", "Межсайтовый скриптинг (XSS)", "Перечисление пользователей (User Enumeration)", "Небезопасная прямая ссылка на объект (IDOR)"], correctAnswerIndex: 2 },
    { question: "Какова лучшая практика для сообщений об ошибках на форме входа для предотвращения перечисления пользователей?", answers: ["Показывать разные сообщения для неверного логина и пароля.", "Использовать общее сообщение, например, 'Неверное имя пользователя или пароль'.", "Не показывать никаких сообщений об ошибках.", "Перенаправлять на главную страницу при любой ошибке."], correctAnswerIndex: 1 },
    { question: "Кроме различных сообщений об ошибках, какое еще поведение сервера может привести к перечислению пользователей?", answers: ["Использование CAPTCHA после нескольких попыток.", "Разное время ответа сервера для действительных и недействительных имен пользователей.", "Блокировка учетной записи после неудачных попыток.", "Требование многофакторной аутентификации."], correctAnswerIndex: 1 },
    { question: "Каково основное назначение 'перца' (pepper) при хешировании паролей?", answers: ["Сделать хеш уникальным для каждого пользователя.", "Увеличить скорость вычисления хеша.", "Добавить секретное значение, хранящееся вне базы данных, для дополнительного уровня защиты.", "Заменить необходимость в 'соли'."], correctAnswerIndex: 2 },
    { question: "Какой из этих алгоритмов хеширования сегодня считается небезопасным для хранения паролей?", answers: ["Bcrypt", "Argon2", "scrypt", "MD5"], correctAnswerIndex: 3 },
    { question: "Что такое 'фактор стоимости' (cost factor) в таких алгоритмах, как Bcrypt?", answers: ["Стоимость лицензии на использование алгоритма.", "Параметр для управления вычислительной 'медленностью' хеша для защиты от перебора.", "Количество символов, добавляемых к паролю.", "Длина итогового хеша в байтах."], correctAnswerIndex: 1 },
    { question: "Почему хранить пароли в виде простого текста (plaintext) является критической уязвимостью?", answers: ["Это замедляет процесс входа в систему.", "Пароли видны любому, кто имеет доступ к базе данных.", "Это нарушает стандарты HTML5.", "Это требует больше места для хранения."], correctAnswerIndex: 1 },
    { question: "Что делает функция password_verify() в PHP?", answers: ["Генерирует новый хеш пароля.", "Проверяет, соответствует ли пароль политике сложности.", "Безопасно сравнивает пароль в открытом виде с существующим хешем.", "Проверяет, не был ли пароль скомпрометирован в утечках."], correctAnswerIndex: 2 },
    { question: "В чем заключается основной недостаток аутентификации на основе знаний (KBA), использующей 'секретные вопросы'?", answers: ["Пользователи часто забывают ответы.", "Ответы часто можно найти в открытых источниках (OSINT).", "Их сложно реализовать технически.", "Они требуют много места в базе данных."], correctAnswerIndex: 1 },
    { question: "Какими свойствами должен обладать безопасный токен для сброса пароля?", answers: ["Быть многоразовым и бессрочным.", "Быть одинаковым для всех пользователей.", "Быть одноразовым и ограниченным по времени действия.", "Содержать пароль пользователя в зашифрованном виде."], correctAnswerIndex: 2 },
    { question: "Какое сообщение должна отображать форма сброса пароля после того, как пользователь ввел свой email?", answers: ["'Пользователь с таким email не найден'.", "'Ссылка для сброса пароля отправлена на ваш email'.", "Общее сообщение, не подтверждающее существование email, например: 'Если учетная запись с таким адресом существует, мы отправили на нее инструкции'.", "'Ошибка: неверный email'."], correctAnswerIndex: 2 },
    { question: "В безопасной реализации функции 'Запомнить меня' с использованием селектора и валидатора, что хранится в cookie пользователя?", answers: ["Имя пользователя и хеш пароля.", "Селектор и валидатор в открытом виде.", "Только селектор.", "Только зашифрованный валидатор."], correctAnswerIndex: 1 },
    { question: "Что должно произойти с токеном 'Запомнить меня' после его успешного использования для входа в систему?", answers: ["Его срок действия должен быть продлен.", "Он должен быть аннулирован, а новый сгенерирован.", "Он должен остаться без изменений.", "Он должен быть записан в лог-файл."], correctAnswerIndex: 1 },
    { question: "Система, которая по умолчанию запрещает доступ при возникновении непредвиденной ошибки в модуле аутентификации, следует какому принципу?", answers: ["Fail-Open", "Fail-Safe", "Fail-Closed", "Fail-Fast"], correctAnswerIndex: 2 },
    { question: "В каком сценарии может быть намеренно выбран дизайн Fail-Open, несмотря на риски безопасности?", answers: ["В банковском приложении.", "В системе управления доступом в здание.", "В системе аварийной разблокировки дверей для эвакуации.", "В административной панели сайта."], correctAnswerIndex: 2 },
    { question: "В чем разница между аутентификацией и авторизацией?", answers: ["Это синонимы.", "Аутентификация определяет, кто вы, а авторизация — что вам разрешено делать.", "Авторизация происходит до аутентификации.", "Аутентификация используется для API, а авторизация — для веб-интерфейсов."], correctAnswerIndex: 1 },
    { question: "Какая категория OWASP Top 10 2021 в первую очередь охватывает такие проблемы, как слабые пароли и credential stuffing?", answers: ["A01: Broken Access Control", "A02: Cryptographic Failures", "A07: Identification and Authentication Failures", "A03: Injection"], correctAnswerIndex: 2 },
    { question: "Хранение паролей, хешированных с помощью MD5 без 'соли', подпадает под какую категорию OWASP Top 10 2021?", answers: ["A07: Identification and Authentication Failures", "A02: Cryptographic Failures", "A05: Security Misconfiguration", "A04: Insecure Design"], correctAnswerIndex: 1 },
    { question: "Какова цель OSINT (разведки по открытым источникам) в контексте атаки на аутентификацию?", answers: ["Найти уязвимости в исходном коде приложения.", "Собрать информацию для социальной инженерии или для ответов на секретные вопросы.", "Провести DoS-атаку на сервер аутентификации.", "Перехватить сетевой трафик."], correctAnswerIndex: 1 },
    { question: "Какова рекомендуемая минимальная длина пароля согласно современным рекомендациям NIST?", answers: ["4 символа.", "6 символов.", "Не менее 8-12 символов, с поддержкой длинных парольных фраз.", "Ровно 16 символов."], correctAnswerIndex: 2 },
    { question: "Злоумышленник похитил базу данных, где токены 'Запомнить меня' хранятся в виде user_id:selector:hashed_validator. Что является основной защитой от их немедленного повторного использования?", answers: ["Срок действия токена.", "У злоумышленника нет валидатора в открытом виде из cookie пользователя.", "IP-адрес пользователя привязан к токену.", "Токены зашифрованы."], correctAnswerIndex: 1 },
    { question: "Вы тестируете форму входа и замечаете, что запросы с действительными именами пользователей отвечают за 500 мс, а с недействительными — за 200 мс. Как называется эта уязвимость?", answers: ["Переполнение буфера.", "Временное перечисление пользователей (Time-based User Enumeration).", "Атака повторного воспроизведения (Replay Attack).", "Межсайтовый скриптинг (XSS)."], correctAnswerIndex: 1 },
    { question: "Разработчик использует base64_encode() для 'защиты' паролей перед сохранением в базу данных. Почему это небезопасно?", answers: ["Base64 — это формат кодирования, а не шифрования, и он легко обратим.", "Функция base64_encode() работает очень медленно.", "Результат кодирования занимает слишком много места.", "Эта функция устарела и больше не поддерживается."], correctAnswerIndex: 0 },
    { question: "Каково главное преимущество использования адаптивного алгоритма хеширования, такого как Argon2, по сравнению с быстрым, как SHA-256, для паролей?", answers: ["Адаптивные алгоритмы создают более короткие хеши.", "Адаптивные алгоритмы можно сделать медленнее, чтобы противостоять взлому на GPU.", "Адаптивные алгоритмы не требуют 'соли'.", "Адаптивные алгоритмы обратимы."], correctAnswerIndex: 1 },
    { question: "После успешного входа пользователя, что сервер должен немедленно сделать с идентификатором сессии?", answers: ["Продлить срок его действия.", "Аннулировать старый идентификатор сессии (до входа) и сгенерировать новый.", "Записать его в открытый лог-файл.", "Отправить его пользователю по email."], correctAnswerIndex: 1 },
    { question: "Какой HTTP-заголовок помогает предотвратить кликджекинг (clickjacking) на формах входа?", answers: ["Access-Control-Allow-Origin", "X-Powered-By", "X-Frame-Options или Content-Security-Policy: frame-ancestors", "Server"], correctAnswerIndex: 2 },
    { question: "В лабораторной работе по брутфорсу DVWA, почему успешная попытка входа имела другую длину (Length) ответа?", answers: ["Сервер добавил в ответ случайные данные.", "Сервер ответил перенаправлением (HTTP 302), тело которого отличалось от страницы с ошибкой входа.", "Успешный ответ был сжат, а ошибочный — нет.", "Браузер отправил другой заголовок Content-Length."], correctAnswerIndex: 1 },
    { question: "Что является основной защитой от атак с использованием радужных таблиц (rainbow table attacks)?", answers: ["Использование очень длинных паролей.", "Использование уникальной 'соли' для каждого пароля.", "Блокировка учетной записи после неудачных попыток.", "Использование HTTPS."], correctAnswerIndex: 1 },
    { question: "Приложение требует от пользователей менять пароль каждые 90 дней. Является ли это рекомендуемой практикой согласно современным руководствам NIST?", answers: ["Да, это повышает безопасность.", "Нет, это побуждает пользователей создавать предсказуемые пароли и повторно их использовать.", "Да, но только если пароли короткие.", "Нет, пароли следует менять каждый день."], correctAnswerIndex: 1 },
    { question: "Какой самый безопасный способ передачи учетных данных от клиента к серверу?", answers: ["В параметрах URL.", "Через соединение HTTP.", "Через соединение HTTPS.", "В виде простого текста в POST-запросе."], correctAnswerIndex: 2 },
    { question: "JWT (JSON Web Token), используемый для аутентификации, содержит права доступа пользователя в своей полезной нагрузке. Если токен только подписан, но не зашифрован, в чем заключается риск?", answers: ["Любой может подделать токен.", "Любой, кто перехватит токен, сможет прочитать права доступа пользователя.", "Токен будет недействителен.", "Сервер не сможет его проверить."], correctAnswerIndex: 1 },
    { question: "Каково назначение CAPTCHA на форме входа?", answers: ["Ускорить процесс входа.", "Запомнить пользователя в системе.", "Предотвратить автоматизированные атаки, такие как брутфорс, отличая людей от ботов.", "Проверить сложность пароля."], correctAnswerIndex: 2 },
    { question: "Злоумышленник находит на веб-сервере файл резервной копии users.sql.bak. Примером какого сбоя это является?", answers: ["Недостатки криптографии.", "Небезопасный дизайн.", "Неправильная конфигурация безопасности (Security Misconfiguration).", "Уязвимость инъекции."], correctAnswerIndex: 2 },
    { question: "В кейс-стади из OWASP Juice Shop, почему пароль пользователя Jim был легко сброшен?", answers: ["Он использовал очень простой пароль.", "Ответ на его секретный вопрос был общеизвестен и мог быть найден через OSINT.", "В функции сброса была SQL-инъекция.", "Его токен сброса был перехвачен."], correctAnswerIndex: 1 },
    { question: "Какова роль функции password_needs_rehash() в PHP?", answers: ["Проверить, нужно ли пользователю сменить пароль.", "Проверить, использует ли сохраненный хеш устаревшие параметры (например, фактор стоимости) и нуждается ли в обновлении.", "Создать новый хеш для нового пользователя.", "Удалить старый хеш из базы данных."], correctAnswerIndex: 1 },
    { question: "Приложение блокирует учетную запись на 10 минут после 5 неудачных попыток входа. Какую потенциальную новую уязвимость это может создать?", answers: ["Межсайтовый скриптинг (XSS).", "Отказ в обслуживании (Denial of Service), когда злоумышленник может блокировать легитимных пользователей.", "SQL-инъекция.", "Подделка межсайтовых запросов (CSRF)."], correctAnswerIndex: 1 },
    { question: "Что из перечисленного НЕ является фактором аутентификации?", answers: ["То, что вы знаете (пароль).", "То, чем вы владеете (телефон для MFA).", "То, чем вы являетесь (отпечаток пальца).", "То, что вы создаете (имя пользователя)."], correctAnswerIndex: 3 },
    { question: "Злоумышленник использует полезную нагрузку ' OR 1=1 -- на форме входа. К какому типу атак это относится?", answers: ["Межсайтовый скриптинг (XSS).", "Внедрение команд (Command Injection).", "SQL-инъекция.", "Обход пути (Path Traversal)."], correctAnswerIndex: 2 },
    { question: "Почему важно аннулировать ссылку для сброса пароля после ее использования?", answers: ["Чтобы освободить место в базе данных.", "Чтобы предотвратить ее повторное использование, если email будет скомпрометирован позже.", "Чтобы пользователь не мог сбросить пароль слишком часто.", "Это требование стандарта HTTP."], correctAnswerIndex: 1 },
    { question: "В чем основное различие между 'солью' и 'перцем' при хешировании паролей?", answers: ["'Соль' длиннее 'перца'.", "'Соль' уникальна для каждого пользователя и хранится в БД; 'перец' — это общесистемный секрет, хранящийся отдельно.", "'Перец' используется вместо 'соли'.", "'Соль' добавляется до пароля, а 'перец' — после."], correctAnswerIndex: 1 },
    { question: "Функция 'Забыли пароль' на сайте отправляет пользователю его текущий пароль по электронной почте. Это признак какой критической уязвимости?", answers: ["Пароли хранятся в открытом виде или обратимо зашифрованы.", "Почтовый сервер настроен неправильно.", "В приложении есть XSS-уязвимость.", "Используется слабая политика паролей."], correctAnswerIndex: 0 },
    { question: "Для чего в первую очередь предназначен протокол OAuth?", answers: ["Для прямого входа пользователя с логином и паролем.", "Для делегированной авторизации, позволяющей одному приложению получать доступ к ресурсам от имени пользователя из другого приложения.", "Для шифрования всего трафика сайта.", "Для хранения паролей."], correctAnswerIndex: 1 },
    { question: "Вы обнаружили, что веб-сайт использует MD5-хеш имени пользователя в качестве токена 'Запомнить меня'. Почему это небезопасно?", answers: ["MD5 — медленный алгоритм.", "Токен предсказуем и не является случайным.", "Имя пользователя может быть слишком длинным.", "MD5-хеши нельзя хранить в cookie."], correctAnswerIndex: 1 },
    { question: "При внедрении ограничения частоты запросов (rate limiting), на чем оно должно основываться: на IP-адресе, имени пользователя или на обоих?", answers: ["Только на IP-адресе.", "Только на имени пользователя.", "На обоих, для обеспечения многоуровневой защиты от различных сценариев атак.", "Ни на одном из них, rate limiting неэффективен."], correctAnswerIndex: 2 },
    { question: "Какова цель ведения журнала неудачных попыток входа?", answers: ["Чтобы напомнить пользователям их неудачные пароли.", "Чтобы обнаруживать потенциальные атаки методом перебора и оповещать о них.", "Чтобы замедлить работу приложения для злоумышленников.", "Это требование для всех веб-сайтов без исключения."], correctAnswerIndex: 1 },
    { question: "Разработчик решил написать собственный криптографический алгоритм для хранения паролей. Почему это, как правило, плохая идея?", answers: ["Это может нарушать авторские права.", "Создать безопасный алгоритм чрезвычайно сложно, и лучше использовать проверенные стандартные алгоритмы.", "Собственные алгоритмы работают медленнее стандартных.", "Это увеличит размер приложения."], correctAnswerIndex: 1 },
    { question: "Каков был заключительный шаг в лабораторной работе OWASP Juice Shop по взлому MD5-хеша администратора?", answers: ["Написание собственного скрипта для перебора.", "Использование радужной таблицы, скачанной из интернета.", "Использование онлайн-сервиса для взлома хешей, такого как CrackStation.", "Декодирование хеша с помощью Base64."], correctAnswerIndex: 2 }
  ];

interface QuizItemProps {
  question: string;
  answers: string[];
  correctAnswerIndex: number;
}

const QuizItem: React.FC<QuizItemProps> = ({ question, answers, correctAnswerIndex }) => {
  const [selectedAnswer, setSelectedAnswer] = React.useState<number | null>(null);

  const handleAnswerClick = (index: number) => {
    setSelectedAnswer(index);
  };

  const isAnswered = selectedAnswer !== null;

  return (
    <div className="mb-6 p-4 border rounded-lg bg-card shadow-sm">
      <p className="font-semibold text-foreground mb-3">{question}</p>
      <ul className="space-y-2">
        {answers.map((answer, index) => {
          const isCorrect = index === correctAnswerIndex;
          const isSelected = selectedAnswer === index;
          
          let itemClass = "cursor-pointer p-2 rounded-md transition-colors duration-200 border border-transparent";
          if (isAnswered) {
            if (isCorrect) {
              itemClass = cn(itemClass, "bg-green-100 dark:bg-green-900/30 border-green-500 text-green-800 dark:text-green-300 font-medium");
            } else if (isSelected) {
              itemClass = cn(itemClass, "bg-red-100 dark:bg-red-900/30 border-red-500 text-red-800 dark:text-red-300");
            } else {
               itemClass = cn(itemClass, "text-muted-foreground");
            }
          } else {
            itemClass = cn(itemClass, "hover:bg-accent hover:text-accent-foreground");
          }

          return (
            <li
              key={index}
              onClick={() => !isAnswered && handleAnswerClick(index)}
              className={itemClass}
            >
              <span className="mr-2">{String.fromCharCode(97 + index)})</span>{answer}
              {isAnswered && isSelected && !isCorrect && (
                  <span className="text-xs ml-2 text-red-600 dark:text-red-400">(Неверно)</span>
              )}
               {isAnswered && isCorrect && (
                  <span className="text-xs ml-2 text-green-700 dark:text-green-400 font-bold">(Правильный ответ)</span>
              )}
            </li>
          );
        })}
      </ul>
    </div>
  );
};


export default function Module3Lesson1Page() {
  return (
    <ContentPageLayout
      title="Урок 1: Атака на Аутентификацию: Теория и Практика"
      subtitle="Модуль III: Атаки на Ключевые Механизмы Приложения"
    >
        <H2 id="a">A. Введение: Технологии и Поверхность Атаки Аутентификации</H2>
        
        <H3 id="a-1">1.1 Роль аутентификации в безопасности приложений</H3>
        <P>
          Аутентификация представляет собой фундаментальный механизм, который лежит в основе безопасности практически любого современного веб-приложения. Это процесс проверки подлинности субъекта (пользователя или системы), пытающегося получить доступ к ресурсам. В контексте методологии WAHH2 и классификации OWASP Top 10, механизмы аутентификации являются "первым рубежом обороны".<Link href="#source-1" className={LinkStyle}><sup className="align-super text-xs">1</sup></Link> Ошибки в этом механизме, классифицируемые как A07:2021 - Identification and Authentication Failures, могут привести к полной компрометации системы.<Link href="#source-2" className={LinkStyle}><sup className="align-super text-xs">2</sup></Link>
        </P>
        <P>
          Важно понимать, что аутентификация — это не просто одна из многих уязвимостей, а точка входа, которая открывает доступ к остальной части приложения. Предыдущие уроки нашего курса были сосредоточены на поиске и эксплуатации уязвимостей, доступных неаутентифицированному пользователю. Данный урок знаменует собой критически важный переход: получение аутентифицированного доступа. Успешная атака на аутентификацию каскадно увеличивает серьезность других, ранее недоступных или низкоприоритетных уязвимостей. Например, уязвимость типа "Broken Access Control" (A01:2021) может быть неэксплуатируемой без предварительного входа в систему.<Link href="#source-3" className={LinkStyle}><sup className="align-super text-xs">3</sup></Link> Таким образом, компрометация аутентификации расширяет поверхность атаки и часто является первым шагом в сложной цепочке эксплойтов, ведущих к захвату контроля над приложением или утечке конфиденциальных данных.<Link href="#source-4" className={LinkStyle}><sup className="align-super text-xs">4</sup></Link>
        </P>

        <H3 id="a-2">1.2 Обзор технологий аутентификации</H3>
        <P>
          Прежде чем атаковать механизм, необходимо понять, как он устроен. Существует множество технологий и подходов к аутентификации, каждый со своими сильными и слабыми сторонами.
        </P>
        <P><strong>Идентификация, Аутентификация и Авторизация:</strong> Важно различать эти три понятия.</P>
        <Ul items={[
            "Идентификация: Процесс, в ходе которого пользователь заявляет о своей личности (например, вводя логин).",
            "Аутентификация: Процесс проверки заявленной личности (например, проверка пароля).",
            "Авторизация: Процесс предоставления прав доступа к определенным ресурсам аутентифицированному пользователю (например, проверка, имеет ли пользователь 'admin' доступ к панели администратора)."
        ]}/>
        <P><strong>Основные методы аутентификации:</strong></P>
        <Ul items={[
            "Пароли: Самый распространенный, но и самый уязвимый метод. Безопасность зависит от сложности пароля и надежности его хранения.",
            "Многофакторная аутентификация (MFA): Требует от пользователя предоставления двух или более доказательств своей личности. Это значительно повышает безопасность, даже если один из факторов (например, пароль) скомпрометирован.",
            "Токены (например, JWT - JSON Web Tokens): Используются в современных API и одностраничных приложениях (SPA) для поддержания сессии без необходимости отправлять учетные данные при каждом запросе.",
            "Биометрия: Использование уникальных физических характеристик (отпечаток пальца, лицо) для аутентификации.",
            "OAuth: Открытый протокол авторизации, который позволяет приложениям предоставлять 'безопасный делегированный доступ' (например, 'Войти с помощью Google')."
        ]}/>
        <P>
          Понимание этих основ позволяет целенаправленно искать слабые места в конкретной реализации аутентификации.
        </P>

        <H2 id="b">B. Ошибки Проектирования в Механизмах Аутентификации</H2>
        <P>
            Многие уязвимости аутентификации возникают не из-за ошибок в коде, а из-за фундаментальных просчетов на этапе проектирования системы.
        </P>

        <H3 id="b-1">2.1 Плохие пароли и атаки полного перебора (Brute-Force)</H3>
        <P>
          Атаки полного перебора (brute-force) являются одним из самых старых, но все еще эффективных методов взлома аутентификации. Их успех обусловлен человеческим фактором: пользователи склонны выбирать простые, запоминающиеся и, следовательно, предсказуемые пароли, а также переиспользовать их на разных сайтах.<Link href="#source-6" className={LinkStyle}><sup className="align-super text-xs">6</sup></Link>
        </P>
        <Ul items={[
            "Атака по словарю (Dictionary Attack): Перебор паролей из заранее составленного списка распространенных паролей.",
            "Credential Stuffing: Использование утекших баз данных с парами 'логин:пароль' для попытки входа на других сайтах. Эта атака особенно эффективна из-за массового переиспользования паролей.",
            "Полный перебор (Exhaustive Brute-Force): Попытка перебрать все возможные комбинации символов. Практически невыполнима для длинных и сложных паролей, но может быть успешной для коротких."
        ]}/>
        
        <Card className="my-6 border-primary/50">
            <CardHeader>
                <CardTitle className="flex items-center text-primary">
                    <FlaskConical className="mr-2 h-5 w-5" />
                    Лаборатория 5.1: Brute-Force атака на DVWA с помощью Burp Intruder
                </CardTitle>
            </CardHeader>
            <CardContent>
                <P>В этом упражнении мы используем Burp Suite Intruder для автоматизации атаки на страницу входа DVWA, пытаясь подобрать и имя пользователя, и пароль.</P>
                <P><strong>Подготовка:</strong></P>
                <Ul items={[
                    "Запустите DVWA в Docker и убедитесь, что уровень безопасности установлен на 'Low'.",
                    "Настройте ваш браузер на работу через Burp Proxy.",
                    "Перейдите на страницу входа DVWA (/login.php). Включите перехват в Burp Proxy (Proxy -> Intercept -> Intercept is on).",
                    "Введите произвольные данные (например, test:test) и нажмите 'Login'.",
                    "Перехваченный POST-запрос появится в Burp. Щелкните правой кнопкой мыши по запросу и выберите 'Send to Intruder'."
                ]} />
                <P><strong>Настройка Intruder:</strong></P>
                <Ul items={[
                    "Перейдите во вкладку Intruder -> Positions.",
                    "Burp автоматически пометит параметры username и password как позиции для полезной нагрузки (payload positions). Если нет, выделите значения этих параметров и нажмите кнопку Add §.",
                    "В выпадающем меню Attack type выберите Cluster bomb. Этот тип атаки идеально подходит для нашего случая, так как он перебирает все возможные комбинации из двух разных списков полезных нагрузок (один для имен пользователей, другой для паролей).<Link href='#source-7' className={LinkStyle}><sup className='align-super text-xs'>7</sup></Link>"
                ]} />
                <P><strong>Конфигурация Payloads:</strong></P>
                <Ul items={[
                    "Перейдите во вкладку Intruder -> Payloads.",
                    "В выпадающем меню Payload set выберите 1 (для параметра username).",
                    "В разделе Payload Options введите небольшой список возможных имен пользователей. Для DVWA можно попробовать: admin, gordonb, 1337, pablo, smithy",
                    "Теперь в Payload set выберите 2 (для параметра password).",
                    "В Payload Options введите список распространенных паролей. Для DVWA password является верным, но для демонстрации добавим еще несколько: password, 123456, qwerty, admin",
                    "Нажмите кнопку Start attack."
                ]} />
                <P><strong>Анализ результатов:</strong></P>
                <Ul items={[
                    "Откроется новое окно Intruder attack. Intruder отправит запрос для каждой комбинации имени пользователя и пароля.",
                    "После завершения атаки отсортируйте результаты по колонке Length (длина ответа).",
                    "Вы заметите, что большинство неудачных попыток имеют одинаковую длину ответа. Однако один запрос (для admin:password) будет иметь другую длину.<Link href='#source-9' className={LinkStyle}><sup className='align-super text-xs'>9</sup></Link> Это происходит потому, что при успешном входе сервер отправляет перенаправление (HTTP-ответ с кодом 302) на главную страницу, и тело ответа отличается.",
                    "Выделите успешный запрос и посмотрите на вкладку Response -> Render, чтобы убедиться, что вы попали на страницу приветствия DVWA."
                ]} />
                <P>Эта лаборатория наглядно демонстрирует, как автоматизированные инструменты могут эффективно эксплуатировать слабые учетные данные и отсутствие защиты от перебора.</P>
            </CardContent>
        </Card>

        <H3>Таблица 1: Сравнение Атак Перебора (Brute-Force) с Помощью Burp Intruder</H3>
        <div className="overflow-x-auto my-6">
            <Table>
                <TableHeader>
                    <TableRow>
                        <TableHead>Тип Атаки (Attack Type)</TableHead>
                        <TableHead>Описание</TableHead>
                        <TableHead>Пример Использования</TableHead>
                        <TableHead>Количество Позиций</TableHead>
                    </TableRow>
                </TableHeader>
                <TableBody>
                    <TableRow><TableCell>Sniper</TableCell><TableCell>Использует один список полезной нагрузки и поочередно подставляет его значения в каждую отмеченную позицию.</TableCell><TableCell>Перебор списка паролей для одного известного имени пользователя.</TableCell><TableCell>1+</TableCell></TableRow>
                    <TableRow><TableCell>Battering ram</TableCell><TableCell>Использует один список полезной нагрузки и одновременно подставляет одно и то же значение во все отмеченные позиции.</TableCell><TableCell>Тестирование, когда имя пользователя и пароль одинаковы.</TableCell><TableCell>1+</TableCell></TableRow>
                    <TableRow><TableCell>Pitchfork</TableCell><TableCell>Использует несколько списков полезной нагрузки. Берет первое значение из первого списка для первой позиции, первое из второго для второй и т.д.</TableCell><TableCell>Перебор списка пар "имя пользователя:пароль", когда они известны и соответствуют друг другу.</TableCell><TableCell>2+</TableCell></TableRow>
                    <TableRow><TableCell>Cluster bomb</TableCell><TableCell>Использует несколько списков полезной нагрузки и перебирает все возможные комбинации значений из этих списков.</TableCell><TableCell>Перебор всех паролей из списка для каждого имени пользователя из другого списка (как в нашей лаборатории).</TableCell><TableCell>2+</TableCell></TableRow>
                </TableBody>
            </Table>
        </div>

        <H3 id="b-2">2.2 Подробные сообщения об ошибках и User Enumeration</H3>
        <P>
            Уязвимость перечисления пользователей (User Enumeration) возникает, когда приложение по-разному реагирует на попытки входа с действительным и недействительным именем пользователя. Это позволяет злоумышленнику составить список зарегистрированных пользователей, который затем можно использовать для более целенаправленных атак.<Link href="#source-10" className={LinkStyle}><sup className="align-super text-xs">10</sup></Link>
        </P>
        <P>Например, приложение может выдавать сообщения:</P>
        <Ul items={[
            "\"Неверный пароль\" — если имя пользователя существует, а пароль нет.",
            "\"Пользователь не найден\" — если имя пользователя не существует."
        ]}/>
        <P>Такое поведение является утечкой информации и нарушает рекомендации OWASP, которые предписывают использовать общие сообщения об ошибках, например: "Неверное имя пользователя или пароль".<Link href="#source-12" className={LinkStyle}><sup className="align-super text-xs">12</sup></Link></P>

        <Card className="my-6 border-primary/50">
            <CardHeader>
                <CardTitle className="flex items-center text-primary">
                    <FlaskConical className="mr-2 h-5 w-5" />
                    Лаборатория 5.2: Эксплуатация User Enumeration в DVWA
                </CardTitle>
            </CardHeader>
            <CardContent>
                <P>Это простое ручное упражнение для демонстрации принципа.</P>
                <P><strong>Цель:</strong> Подтвердить наличие уязвимости User Enumeration в DVWA на уровне "Low".</P>
                <P><strong>Шаги:</strong></P>
                <Ul items={[
                    "Перейдите на страницу входа DVWA (/login.php).",
                    "Введите действительное имя пользователя (admin) и неверный пароль (badpass). Нажмите 'Login'. Обратите внимание на сообщение об ошибке: Username and/or password incorrect.",
                    "Теперь введите недействительное имя пользователя (nonexistentuser) и любой пароль. Нажмите 'Login'."
                ]} />
                <P><strong>Анализ:</strong> На уровне "Low" DVWA не имеет этой уязвимости и выдает одинаковое сообщение. Однако на уровне "Medium" и "High" поведение может отличаться, или же уязвимость может проявляться в разнице времени ответа сервера.</P>
                <P>Настоящая опасность этой уязвимости раскрывается в связке с другими атаками. Получив список действительных пользователей, злоумышленник может перейти от "шумной" атаки Cluster Bomb к более тихой и целенаправленной атаке Sniper из предыдущей лаборатории, значительно сократив количество запросов и вероятность обнаружения. Это демонстрирует итеративный характер тестирования по методологии WAHH2: информация, полученная на одном этапе, используется для уточнения и повышения эффективности атак на следующем.</P>
            </CardContent>
        </Card>

        <H3 id="b-3">2.3 Уязвимые функции смены и восстановления пароля</H3>
        <P>
            Функциональность восстановления пароля — критически важная и часто уязвимая часть приложения. Ошибки проектирования здесь могут позволить злоумышленнику легко захватить чужую учетную запись. Одной из самых слабых практик является использование "секретных вопросов" или аутентификации на основе знаний (KBA - Knowledge-Based Authentication).<Link href="#source-14" className={LinkStyle}><sup className="align-super text-xs">14</sup></Link>
        </P>

        <Card className="my-6 border-accent/50">
            <CardHeader>
                <CardTitle className="flex items-center text-accent-foreground">
                    <BookOpen className="mr-2 h-5 w-5" />
                    Кейс-стади: "Reset Jim's Password" в OWASP Juice Shop
                </CardTitle>
            </CardHeader>
            <CardContent>
                <P>Этот пример из OWASP Juice Shop идеально иллюстрирует, как человеческий фактор и ошибки проектирования приводят к компрометации.</P>
                <P><strong>Уязвимость:</strong> Приложение позволяет сбросить пароль пользователя Jim, ответив на секретный вопрос: "Your eldest siblings middle name?" ("Среднее имя вашего старшего брата/сестры?").<Link href="#source-16" className={LinkStyle}><sup className="align-super text-xs">16</sup></Link></P>
                <P><strong>Проблема:</strong> Уязвимость заключается не в ошибке кода, а в самом дизайнерском решении использовать KBA для известной личности. Ответ на этот вопрос не является секретом и может быть легко найден в открытых источниках.<Link href="#source-17" className={LinkStyle}><sup className="align-super text-xs">17</sup></Link></P>
                <P><strong>Процесс эксплуатации (OSINT):</strong></P>
                <Ul items={[
                    "Разведка (Reconnaissance): Внутри самого приложения есть подсказки, указывающие на личность Jim. В отзывах к товарам он упоминает 'символ Звездного флота' и 'репликатор', а в адресе доставки — 'USS Enterprise'. Это явно указывает на персонажа Джеймса Т. Кирка из 'Star Trek'.",
                    "Сбор информации: Простой поиск в Википедии по запросу 'James T. Kirk' показывает, что у него был брат по имени Джордж Сэмюэл Кирк.",
                    "Эксплуатация: Злоумышленник вводит 'Samuel' в качестве ответа на секретный вопрос и успешно сбрасывает пароль."
                ]}/>
                <P><strong>Вывод:</strong> Этот кейс учит нас тому, что оценка безопасности должна выходить за рамки анализа кода. Тестировщик должен применять навыки разведки из открытых источников (OSINT) и учитывать человеческий фактор. Технически система может быть реализована безупречно, но выбор слабого механизма аутентификации сводит на нет все усилия.<Link href="#source-16" className={LinkStyle}><sup className="align-super text-xs">16</sup></Link></P>
            </CardContent>
        </Card>

        <H3 id="b-4">2.4 Функциональность «Запомнить меня» (Remember Me)</H3>
        <P>
            Функция "Запомнить меня" повышает удобство использования, но создает дополнительные риски. Если она реализована небезопасно, злоумышленник, получивший доступ к cookie пользователя, может получить долгосрочный доступ к его учетной записи.
        </P>
        <P><strong>Небезопасная реализация:</strong> Хранение в cookie идентификатора пользователя и его хешированного пароля. Это крайне опасно, так как утечка cookie равносильна утечке пароля.</P>
        <P><strong>Безопасная реализация (на основе токенов):</strong></P>
        <Ul items={[
            "При успешном входе с опцией 'Запомнить меня' генерируются две части данных: selector (селектор) и validator (валидатор).",
            "В cookie пользователя сохраняется selector:validator.",
            "В базе данных на сервере создается запись: user_id, selector, hashed_validator. Валидатор хешируется для безопасного хранения.",
            "При следующем визите пользователя приложение находит запись в БД по selector из cookie, хеширует validator из cookie и сравнивает его с hashed_validator из БД.",
            "Если они совпадают, пользователь аутентифицируется. Критически важно, чтобы после каждого успешного входа по cookie пара selector:validator пересоздавалась (как в cookie, так и в БД), что делает украденный cookie одноразовым.<Link href='#source-18' className={LinkStyle}><sup className='align-super text-xs'>18</sup></Link>"
        ]}/>

        <H2 id="c">C. Уязвимости Реализации в Аутентификации</H2>
        <P>
            Даже при хорошем дизайне, ошибки в конкретной реализации могут создать серьезные уязвимости.
        </P>
        
        <H3 id="c-1">3.1 Механизмы входа с отказом в открытом состоянии (Fail-Open)</H3>
        <P>
            Это одна из самых коварных уязвимостей, поскольку она часто скрыта в логике обработки исключений. Системы могут быть спроектированы по двум принципам:<Link href='#source-20' className={LinkStyle}><sup className='align-super text-xs'>20</sup></Link>
        </P>
        <Ul items={[
            "Fail-Closed (Безопасный по умолчанию): При возникновении любой ошибки или непредвиденной ситуации система переходит в безопасное состояние, т.е. блокирует доступ. Это приоритет безопасности.",
            "Fail-Open (Открытый по умолчанию): При сбое система продолжает работу или предоставляет доступ. Это приоритет доступности, но он может быть крайне опасен в контексте аутентификации.<Link href='#source-22' className={LinkStyle}><sup className='align-super text-xs'>22</sup></Link>"
        ]}/>
        <P>Представьте себе код проверки учетных данных, который обращается к базе данных. Если соединение с БД обрывается, как должен повести себя код?</P>
        <P>Пример кода (псевдокод):</P>
        <CodeBlock language="python" code={`
# Уязвимая реализация (Fail-Open)
def check_login(username, password):
    try:
        # Эта функция может выбросить исключение, если БД недоступна
        db_result = database.verify_credentials(username, password) 
        return db_result # Вернет True или False
    except DatabaseConnectionError:
        # При ошибке соединения с БД, код по умолчанию разрешает доступ!
        log("Database connection failed, failing open!")
        return True 

# Безопасная реализация (Fail-Closed)
def check_login_secure(username, password):
    try:
        db_result = database.verify_credentials(username, password)
        return db_result
    except DatabaseConnectionError:
        # При ошибке соединения с БД, код по умолчанию запрещает доступ
        log("Database connection failed, failing closed!")
        return False
        `} />
        <P>Уязвимость Fail-Open трудно обнаружить стандартным тестированием. Злоумышленнику может потребоваться вызвать сбой на сервере (например, DoS-атакой на базу данных), чтобы в этот момент попытаться обойти аутентификацию.</P>

        <H3 id="c-2">3.2 Небезопасное хранение учетных данных</H3>
        <P>Это одна из самых распространенных и критических ошибок реализации. Хранение паролей в открытом виде или с использованием устаревших, слабых алгоритмов хеширования делает всю базу пользователей уязвимой в случае утечки данных.</P>
        <P><strong>Основные принципы безопасного хранения:</strong></P>
        <Ul items={[
            "Никогда не хранить пароли в открытом виде.",
            "Использовать сильные, адаптивные алгоритмы хеширования, такие как Bcrypt, scrypt, PBKDF2 или Argon2. Эти алгоритмы намеренно медленные.",
            "Использовать 'соль' (salt): Случайная строка, уникальная для каждого пользователя, которая добавляется к паролю перед хешированием. Соль защищает от атак с использованием 'радужных таблиц' (pre-computed hash tables).<Link href='#source-23' className={LinkStyle}><sup className='align-super text-xs'>23</sup></Link>",
            "Использовать 'перец' (pepper): Секретная строка, общая для всего приложения, которая добавляется к паролю перед хешированием. Она хранится не в БД, а в конфигурационном файле, добавляя еще один уровень защиты.<Link href='#source-25' className={LinkStyle}><sup className='align-super text-xs'>25</sup></Link>",
            "Использовать 'фактор стоимости' (cost factor): Параметр, который позволяет настроить 'медленность' алгоритма. По мере роста вычислительных мощностей, этот фактор можно увеличивать, чтобы поддерживать высокий уровень защиты."
        ]}/>

        <Card className="my-6 border-primary/50">
            <CardHeader>
                <CardTitle className="flex items-center text-primary">
                    <FlaskConical className="mr-2 h-5 w-5" />
                    Лаборатория 5.3: Анализ Небезопасного Хранения Учетных Данных в OWASP Juice Shop
                </CardTitle>
            </CardHeader>
            <CardContent>
                <P>В этом упражнении мы найдем и проанализируем, как OWASP Juice Shop хранит пароли пользователей, демонстрируя последствия использования слабого хеширования.</P>
                <P><strong>Цель:</strong> Извлечь хеши паролей из базы данных Juice Shop и взломать один из них.</P>
                <P><strong>Шаг 1: Получение хешей с помощью SQL-инъекции.</strong></P>
                <P>Вспомним, что многие функции Juice Shop уязвимы к SQL-инъекциям. Поле поиска является одной из таких точек входа.</P>
                <P>Для извлечения всех данных из таблицы Users можно использовать следующую полезную нагрузку в поле поиска:</P>
                <CodeBlock language="sql" code={`qwert')) UNION SELECT id, email, password, '4', '5', '6', '7', '8', '9' FROM Users--`} />
                <P>Эта инъекция заставит приложение вернуть JSON-массив со всеми пользователями, включая их id, email и password.</P>
                <P><strong>Шаг 2: Анализ хешей.</strong></P>
                <P>Изучите полученные данные. Вы увидите, что в поле password находятся 32-символьные шестнадцатеричные строки. Например, для пользователя admin@juice-sh.op хеш будет 0192023a7bbd73250516f069df18b500.</P>
                <P>Этот формат (32 hex-символа) является характерным признаком алгоритма MD5, который давно считается небезопасным для хранения паролей.</P>
                <P><strong>Шаг 3: Взлом хешей.</strong></P>
                <Ul items={[
                    "Скопируйте хеш администратора: 0192023a7bbd73250516f069df18b500.",
                    "Перейдите на любой онлайн-сервис для взлома хешей (например, CrackStation).",
                    "Вставьте хеш в поле для анализа. Сервис мгновенно вернет результат: admin123."
                ]}/>
                <P><strong>Вывод:</strong> Эта лаборатория наглядно показывает, почему использование MD5 для паролей недопустимо. Даже без доступа к 'соли' (которой здесь нет), пароль был восстановлен за доли секунды с помощью предварительно вычисленных таблиц.</P>
            </CardContent>
        </Card>

        <H2 id="d">D. Обеспечение Безопасности Аутентификации (Рекомендации и Лучшие Практики)</H2>
        <P>Этот раздел обобщает контрмеры для всех рассмотренных уязвимостей, формируя чек-лист для построения надежной системы аутентификации.</P>
        
        <H3 id="d-1">4.1 Используйте надежные учетные данные</H3>
        <P><strong>Политика паролей:</strong> Внедрите строгие правила для паролей, основываясь на рекомендациях OWASP и NIST:<Link href='#source-12' className={LinkStyle}><sup className='align-super text-xs'>12</sup></Link></P>
        <Ul items={[
            "Длина: Минимальная длина не менее 10-12 символов. Максимальная — не менее 64, чтобы разрешить использование парольных фраз.",
            "Сложность: Требовать смешения разных типов символов (верхний/нижний регистр, цифры, спецсимволы).",
            "Запрет распространенных паролей: Проверяйте новые пароли по спискам самых распространенных и утекших паролей (например, через сервис Pwned Passwords).",
            "Измеритель надежности: Предоставьте пользователю визуальный индикатор (password strength meter), который поможет ему создать сильный пароль."
        ]}/>

        <H3 id="d-2">4.2 Обращайтесь с учетными данными конфиденциально: Secure Storage</H3>
        <P>Правильное хранение паролей — это не опция, а абсолютная необходимость.</P>
        <P><strong>Практические примеры кода:</strong></P>
        <P>PHP: Используйте встроенные функции password_hash() и password_verify(). Они автоматически управляют генерацией соли и используют надежный алгоритм Bcrypt по умолчанию (PASSWORD_DEFAULT).<Link href='#source-23' className={LinkStyle}><sup className='align-super text-xs'>23</sup></Link></P>
        <CodeBlock language="php" code={`
// Создание хеша при регистрации
$hashed_password = password_hash($_POST['password'], PASSWORD_DEFAULT);
// Сохранение $hashed_password в БД

// Проверка пароля при входе
if (password_verify($_POST['password'], $hashed_password_from_db)) {
    // Успешный вход
    // Проверка, не нужно ли перехешировать пароль с новым, более сильным алгоритмом
    if (password_needs_rehash($hashed_password_from_db, PASSWORD_DEFAULT)) {
        $new_hash = password_hash($_POST['password'], PASSWORD_DEFAULT);
        // Обновить хеш в БД для этого пользователя
    }
}
        `} />
        <P>Функция password_needs_rehash() является примером проактивной защиты. Она позволяет плавно обновлять безопасность хешей для пользователей, не требуя от них смены пароля, когда вы решаете увеличить "cost factor" или перейти на новый алгоритм по умолчанию.<Link href='#source-26' className={LinkStyle}><sup className='align-super text-xs'>26</sup></Link></P>
        <P>Python: Используйте библиотеку bcrypt.<Link href='#source-24' className={LinkStyle}><sup className='align-super text-xs'>24</sup></Link></P>
        <CodeBlock language="python" code={`
import bcrypt

password = b"supersecretpassword"

# Создание хеша с автоматически сгенерированной солью
hashed = bcrypt.hashpw(password, bcrypt.gensalt())

# Проверка пароля
if bcrypt.checkpw(password, hashed):
    print("It matches")
else:
    print("It does not match")
        `} />
        <P>Библиотека bcrypt инкапсулирует всю сложность работы с солями и хешированием, предоставляя простой и надежный интерфейс.</P>

        <H3>Таблица 2: Сводка по Безопасному Хранению Паролей</H3>
        <div className="overflow-x-auto my-6">
            <Table>
                <TableHeader>
                    <TableRow>
                        <TableHead>Метод Хранения</TableHead>
                        <TableHead>Уровень Безопасности</TableHead>
                        <TableHead>Ключевая Слабость</TableHead>
                        <TableHead>Ключевая Особенность (Защита)</TableHead>
                    </TableRow>
                </TableHeader>
                <TableBody>
                    <TableRow><TableCell>Plaintext (Открытый текст)</TableCell><TableCell>Критически небезопасно</TableCell><TableCell>Пароли видны всем, у кого есть доступ к данным.</TableCell><TableCell>Нет защиты.</TableCell></TableRow>
                    <TableRow><TableCell>Base64 / URL Encoding</TableCell><TableCell>Критически небезопасно</TableCell><TableCell>Это кодирование, а не шифрование. Легко обратимо.</TableCell><TableCell>Нет защиты.</TableCell></TableRow>
                    <TableRow><TableCell>MD5 / SHA1 (без соли)</TableCell><TableCell>Небезопасно</TableCell><TableCell>Быстрые алгоритмы, уязвимы к радужным таблицам и коллизиям.</TableCell><TableCell>Одностороннее хеширование.</TableCell></TableRow>
                    <TableRow><TableCell>MD5 / SHA1 (с солью)</TableCell><TableCell>Устарело</TableCell><TableCell>Алгоритмы все еще слишком быстрые для современных GPU.</TableCell><TableCell>Соль защищает от радужных таблиц.</TableCell></TableRow>
                    <TableRow><TableCell>Bcrypt / Argon2id</TableCell><TableCell>Рекомендуется</TableCell><TableCell>Требует больше вычислительных ресурсов.</TableCell><TableCell>Адаптивный cost factor, встроенная соль, намеренная медлительность.</TableCell></TableRow>
                </TableBody>
            </Table>
        </div>

        <H3 id="d-3">4.3 Предотвращайте атаки полного перебора</H3>
        <P>Необходимо внедрять многоуровневую защиту от автоматизированных атак:<Link href="#source-2" className={LinkStyle}><sup className="align-super text-xs">2</sup></Link></P>
        <Ul items={[
            "Ограничение частоты запросов (Rate Limiting): Ограничьте количество неудачных попыток входа с одного IP-адреса за определенный промежуток времени.",
            "CAPTCHA: После нескольких неудачных попыток требуйте от пользователя пройти проверку CAPTCHA, чтобы отсечь ботов.",
            "Блокировка учетной записи (Account Lockout): Временно блокируйте учетную запись после определенного числа неудачных попыток (например, 5 попыток на 15 минут). Это должно быть реализовано осторожно, чтобы не создать уязвимость к DoS-атаке на пользователей."
        ]}/>

        <H3 id="d-4">4.4 Предотвращайте неправомерное использование функции восстановления</H3>
        <P>Следуйте рекомендациям из OWASP Forgot Password Cheat Sheet:<Link href='#source-13' className={LinkStyle}><sup className='align-super text-xs'>13</sup></Link></P>
        <Ul items={[
            "Используйте только внеполосные каналы: Отправляйте токены для сброса пароля только по подтвержденным каналам, таким как email или SMS.",
            "Токены должны быть одноразовыми и ограниченными по времени: Сгенерированный токен должен быть действителен только для одной операции сброса и истекать через короткое время (15-30 минут).",
            "Используйте общие сообщения об ошибках: Никогда не подтверждайте, существует ли введенный email или имя пользователя в системе. Используйте формулировку: 'Если учетная запись с таким адресом существует, мы отправили на нее инструкции по сбросу пароля'.",
            "Никогда не используйте секретные вопросы (KBA)."
        ]}/>

        <H3 id="d-5">4.5 Журналируйте, отслеживайте и оповещайте</H3>
        <P>Адекватное логирование — это основа для обнаружения атак и расследования инцидентов. Необходимо записывать в журнал:<Link href='#source-12' className={LinkStyle}><sup className='align-super text-xs'>12</sup></Link></P>
        <Ul items={[
            "Все успешные и неудачные попытки входа.",
            "Все запросы на сброс пароля.",
            "События блокировки учетной записи.",
            "Изменения пароля."
        ]}/>
        <P>Настройте систему оповещений, которая будет уведомлять администраторов о подозрительной активности, такой как большое количество неудачных входов с одного IP-адреса (признак brute-force) или для одной учетной записи.</P>

        <H3>Таблица 3: Карта Уязвимостей Аутентификации и Методы Защиты (OWASP)</H3>
        <div className="overflow-x-auto my-6">
            <Table>
                <TableHeader>
                    <TableRow>
                        <TableHead>Уязвимость</TableHead>
                        <TableHead>Категория OWASP Top 10</TableHead>
                        <TableHead>Основной Метод Защиты</TableHead>
                        <TableHead>Ссылка на OWASP Cheat Sheet</TableHead>
                    </TableRow>
                </TableHeader>
                <TableBody>
                    <TableRow><TableCell>Brute-Force / Credential Stuffing</TableCell><TableCell>A07:2021</TableCell><TableCell>Rate Limiting, CAPTCHA, Account Lockout, MFA</TableCell><TableCell><Link href="https://cheatsheetseries.owasp.org/cheatsheets/Authentication_Cheat_Sheet.html" target="_blank" rel="noopener noreferrer" className={LinkStyle}>Authentication</Link></TableCell></TableRow>
                    <TableRow><TableCell>User Enumeration</TableCell><TableCell>A07:2021</TableCell><TableCell>Общие (Generic) сообщения об ошибках</TableCell><TableCell><Link href="https://cheatsheetseries.owasp.org/cheatsheets/Authentication_Cheat_Sheet.html" target="_blank" rel="noopener noreferrer" className={LinkStyle}>Authentication</Link></TableCell></TableRow>
                    <TableRow><TableCell>Слабый сброс пароля (KBA)</TableCell><TableCell>A07:2021</TableCell><TableCell>Внеполосные, одноразовые, ограниченные по времени токены</TableCell><TableCell><Link href="https://cheatsheetseries.owasp.org/cheatsheets/Forgot_Password_Cheat_Sheet.html" target="_blank" rel="noopener noreferrer" className={LinkStyle}>Forgot Password</Link></TableCell></TableRow>
                    <TableRow><TableCell>Небезопасная функция "Remember Me"</TableCell><TableCell>A07:2021</TableCell><TableCell>Безопасные долгоживущие токены (Selector/Validator)</TableCell><TableCell><Link href="https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html" target="_blank" rel="noopener noreferrer" className={LinkStyle}>Session Management</Link></TableCell></TableRow>
                    <TableRow><TableCell>Небезопасное хранение (слабый хеш)</TableCell><TableCell>A02:2021</TableCell><TableCell>Адаптивное хеширование с солью (Bcrypt, Argon2)</TableCell><TableCell><Link href="https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html" target="_blank" rel="noopener noreferrer" className={LinkStyle}>Password Storage</Link></TableCell></TableRow>
                    <TableRow><TableCell>Логика Fail-Open</TableCell><TableCell>A05:2021</TableCell><TableCell>Проектирование с принципом Fail-Closed</TableCell><TableCell><Link href="https://cheatsheetseries.owasp.org/cheatsheets/Error_Handling_Cheat_Sheet.html" target="_blank" rel="noopener noreferrer" className={LinkStyle}>Error Handling</Link></TableCell></TableRow>
                </TableBody>
            </Table>
        </div>
        
        <H2 id="e">E. Блок контроля знаний (Урок 5)</H2>
        <Card>
            <CardHeader>
                <CardTitle>Тест по теме</CardTitle>
                <CardDescription>Проверьте свои знания, выбрав правильный вариант ответа.</CardDescription>
            </CardHeader>
            <CardContent>
                {quizQuestions.map((q, index) => (
                    <QuizItem key={index} {...q} />
                ))}
            </CardContent>
        </Card>

        <H2 id="sources">Источники</H2>
        <ol className="list-decimal list-inside space-y-2 text-sm">
            {sourcesData.map(source => (
                <li key={source.id} id={`source-${source.id}`}>
                    {source.url ? (
                        <Link href={source.url} target="_blank" rel="noopener noreferrer" className={LinkStyle}>{source.text}</Link>
                    ) : (
                        source.text
                    )}
                </li>
            ))}
        </ol>

    </ContentPageLayout>
  );
}
