'use client';

import { P, H2, H3, Ul } from '@/components/content/ContentPageLayout';
import Image from 'next/image';

// TODO: Replace with actual image paths or remove if not needed
const placeholderImage = "https://placehold.co/600x400.png";

export function BookChapterTextSection() {
  return (
    <article className="prose prose-lg mx-auto max-w-3xl py-8 dark:prose-invert">
      <H2>Основные механизмы защиты</H2>
      <P>
        Фундаментальная проблема безопасности веб-приложений — недоверие ко всем данным, вводимым пользователем — порождает ряд защитных механизмов, которые приложения используют для самообороны. Практически все приложения используют концептуально схожие механизмы, хотя детали их проектирования и эффективность реализации сильно различаются.
      </P>
      <P>
        Механизмы защиты, применяемые веб-приложениями, включают в себя следующие ключевые элементы:
      </P>
      <Ul items={[
        "Управление доступом пользователей к данным и функциональности приложения для предотвращения несанкционированного доступа.",
        "Обработка пользовательского ввода в функциях приложения для предотвращения нежелательного поведения, вызванного некорректными данными.",
        "Противодействие злоумышленникам для обеспечения адекватного поведения приложения при прямой атаке, с принятием соответствующих оборонительных и наступательных мер для затруднения действий злоумышленника.",
        "Управление самим приложением, позволяющее администраторам отслеживать его активность и настраивать функциональность."
      ]} />
      <P>
        Из-за своей центральной роли в решении основной проблемы безопасности, эти механизмы также составляют подавляющее большинство поверхности атаки типичного приложения. Если первое правило войны — «знай своего врага», то полное понимание этих механизмов является главным предварительным условием для эффективной атаки на приложения. Если вы новичок в хакинге веб-приложений (и даже если нет), вам следует уделить время изучению того, как работают эти основные механизмы в каждом из встречающихся вам приложений, и выявлять слабые места, которые делают их уязвимыми для атак.
      </P>

      <H3>Управление доступом пользователей</H3>
      <P>
        Ключевое требование безопасности, которому должно соответствовать практически любое приложение, — это контроль доступа пользователей к его данным и функциональности. Типичная ситуация включает несколько различных категорий пользователей, таких как анонимные пользователи, обычные аутентифицированные пользователи и администраторы. Кроме того, во многих случаях разным пользователям разрешен доступ к разному набору данных. Например, пользователи почтового веб-приложения должны иметь возможность читать свою электронную почту, но не чужую.
      </P>
      <P>
        Большинство веб-приложений управляют доступом с помощью триады взаимосвязанных механизмов безопасности:
      </P>
      <Ul items={[
        "Аутентификация",
        "Управление сессиями",
        "Контроль доступа"
      ]} />
      <P>
        Каждый из этих механизмов представляет собой значительную область поверхности атаки приложения, и каждый из них является фундаментальным для общей безопасности приложения. Из-за их взаимозависимости общая безопасность, обеспечиваемая этими механизмами, сильна лишь настолько, насколько сильно самое слабое звено в цепи. Дефект в любом отдельном компоненте может позволить злоумышленнику получить неограниченный доступ к функциональности и данным приложения.
      </P>

      <H3>Аутентификация</H3>
      <P>
        Механизм аутентификации логически является самой базовой зависимостью в обработке доступа пользователей приложением. Аутентификация пользователя включает в себя установление того, что пользователь действительно является тем, за кого себя выдает. Без этой возможности приложению пришлось бы рассматривать всех пользователей как анонимных — самый низкий возможный уровень доверия.
      </P>
      <P>
        Большинство современных веб-приложений используют традиционную модель аутентификации, при которой пользователь отправляет имя пользователя и пароль, которые приложение проверяет на валидность. На Рисунке 2-1 показана типичная функция входа в систему.
      </P>
      <figure className="my-6 text-center">
        <Image
          src={placeholderImage}
          alt="Рисунок 2-1: Типичная функция входа в систему"
          width={600}
          height={400}
          className="mx-auto rounded-md shadow-md"
          data-ai-hint="login form interface"
        />
        <figcaption className="mt-2 text-sm text-muted-foreground">
          <em>Рисунок 2-1: Типичная функция входа в систему</em>
        </figcaption>
      </figure>
      <P>
        В критически важных с точки зрения безопасности приложениях, таких как те, что используются онлайн-банками, эта базовая модель обычно дополняется дополнительными учетными данными и многоэтапным процессом входа. Когда требования безопасности еще выше, могут использоваться другие модели аутентификации, основанные на клиентских сертификатах, смарт-картах или токенах с запросом-ответом. Помимо основного процесса входа, механизмы аутентификации часто используют ряд других вспомогательных функций, таких как саморегистрация, восстановление учетной записи и смена пароля.
      </P>
      <P>
        Несмотря на их кажущуюся простоту, механизмы аутентификации страдают от широкого спектра дефектов как в проектировании, так и в реализации. Распространенные проблемы могут позволить злоумышленнику определить имена пользователей других людей, угадать их пароли или обойти функцию входа, используя дефекты в ее логике. При атаке на веб-приложение следует уделить значительное внимание различным функциям, связанным с аутентификацией. Удивительно часто дефекты в этой функциональности позволяют получить несанкционированный доступ к конфиденциальным данным и функциям.
      </P>

      <H3>Управление сессиями</H3>
      <P>
        Следующей логической задачей в процессе управления доступом пользователей является управление сессией аутентифицированного пользователя. После успешного входа в приложение пользователь получает доступ к различным страницам и функциям, совершая серию HTTP-запросов из своего браузера. В то же время приложение получает бесчисленное множество других запросов от разных пользователей, некоторые из которых аутентифицированы, а некоторые анонимны. Для обеспечения эффективного контроля доступа приложению необходим способ идентификации и обработки серии запросов, исходящих от каждого уникального пользователя.
      </P>
      <P>
        Практически все веб-приложения отвечают этому требованию, создавая сессию для каждого пользователя и выдавая ему токен, идентифицирующий эту сессию. Сама сессия представляет собой набор структур данных на сервере, которые отслеживают состояние взаимодействия пользователя с приложением. Токен — это уникальная строка, которую приложение сопоставляет с сессией. Когда пользователь получает токен, браузер автоматически отправляет его обратно на сервер в каждом последующем HTTP-запросе, что позволяет приложению связать запрос с этим пользователем. HTTP-cookie являются стандартным методом передачи токенов сессии, хотя многие приложения используют для этой цели скрытые поля формы или строку запроса URL. Если пользователь не делает запрос в течение определенного времени, сессия в идеале истекает, как показано на Рисунке 2-2.
      </P>
      <figure className="my-6 text-center">
        <Image
          src={placeholderImage}
          alt="Рисунок 2-2: Приложение, обеспечивающее тайм-аут сессии"
          width={600}
          height={400}
          className="mx-auto rounded-md shadow-md"
          data-ai-hint="session timeout message"
        />
        <figcaption className="mt-2 text-sm text-muted-foreground">
          <em>Рисунок 2-2: Приложение, обеспечивающее тайм-аут сессии</em>
        </figcaption>
      </figure>
      <P>
        С точки зрения поверхности атаки, механизм управления сессиями сильно зависит от безопасности своих токенов. Большинство атак на него направлены на компрометацию токенов, выданных другим пользователям. Если это возможно, злоумышленник может выдать себя за пользователя-жертву и использовать приложение так, как если бы он действительно аутентифицировался как этот пользователь. Основные области уязвимости возникают из-за дефектов в том, как генерируются токены, что позволяет злоумышленнику угадывать токены, выданные другим пользователям, и дефектов в том, как токены обрабатываются впоследствии, что позволяет злоумышленнику перехватывать токены других пользователей.
      </P>
      <P>
        Небольшое количество приложений обходится без токенов сессии, используя другие средства для повторной идентификации пользователей в нескольких запросах. Если используется встроенный механизм аутентификации HTTP, браузер автоматически повторно отправляет учетные данные пользователя с каждым запросом, позволяя приложению идентифицировать пользователя непосредственно по ним. В других случаях приложение хранит информацию о состоянии на стороне клиента, а не на сервере, обычно в зашифрованном виде для предотвращения подделки.
      </P>

      <H3>Контроль доступа</H3>
      <P>
        Последним логическим шагом в процессе управления доступом пользователей является принятие и применение правильных решений о том, следует ли разрешить или отклонить каждый отдельный запрос. Если описанные выше механизмы функционируют правильно, приложение знает личность пользователя, от которого получен каждый запрос. На этом основании оно должно решить, уполномочен ли этот пользователь выполнять действие или получать доступ к данным, которые он запрашивает, как показано на Рисунке 2-3.
      </P>
      <figure className="my-6 text-center">
        <Image
          src={placeholderImage}
          alt="Рисунок 2-3: Приложение, обеспечивающее контроль доступа"
          width={600}
          height={400}
          className="mx-auto rounded-md shadow-md"
          data-ai-hint="access control diagram"
        />
        <figcaption className="mt-2 text-sm text-muted-foreground">
          <em>Рисунок 2-3: Приложение, обеспечивающее контроль доступа</em>
        </figcaption>
      </figure>
      <P>
        Механизм контроля доступа обычно должен реализовывать некоторую детализированную логику, с различными соображениями, относящимися к разным областям приложения и разным типам функциональности. Приложение может поддерживать многочисленные роли пользователей, каждая из которых включает различные комбинации конкретных привилегий. Отдельным пользователям может быть разрешен доступ к подмножеству всех данных, хранящихся в приложении. Конкретные функции могут реализовывать лимиты транзакций и другие проверки, все из которых должны быть должным образом применены на основе личности пользователя.
      </P>
      <P>
        Из-за сложного характера типичных требований контроля доступа этот механизм часто является источником уязвимостей безопасности, которые позволяют злоумышленнику получить несанкционированный доступ к данным и функциональности. Разработчики часто делают ошибочные предположения о том, как пользователи будут взаимодействовать с приложением, и часто допускают упущения, пропуская проверки контроля доступа в некоторых функциях приложения. Поиск этих уязвимостей часто трудоемок, поскольку по сути одни и те же проверки необходимо повторять для каждого элемента функциональности. Однако из-за распространенности недостатков контроля доступа эти усилия всегда являются оправданной инвестицией при атаке на веб-приложение. В Главе 8 описывается, как можно автоматизировать некоторые усилия, связанные с проведением тщательного тестирования контроля доступа.
      </P>

      <H2>Обработка пользовательского ввода</H2>
      <P>
        Вспомним фундаментальную проблему безопасности, описанную в Главе 1: все вводимые пользователем данные не заслуживают доверия. Огромное разнообразие атак на веб-приложения включает в себя отправку неожиданных входных данных, созданных для вызова поведения, не предусмотренного разработчиками приложения. Соответственно, ключевым требованием к защитным механизмам приложения является безопасная обработка пользовательского ввода.
      </P>
      <P>
        Уязвимости, связанные с вводом данных, могут возникать в любой части функциональности приложения и в отношении практически любого типа широко используемых технологий. «Проверка ввода» часто упоминается как необходимая защита от этих атак. Однако ни один защитный механизм не может быть применен повсеместно, и защита от вредоносного ввода часто не так проста, как кажется.
      </P>

      <H3>Разновидности ввода</H3>
      <P>
        Типичное веб-приложение обрабатывает данные, предоставленные пользователем, в самых разных формах. Некоторые виды проверки ввода могут быть нецелесообразными или нежелательными для всех этих форм ввода. На Рисунке 2-4 показан тип проверки ввода, часто выполняемый функцией регистрации пользователя.
      </P>
      <figure className="my-6 text-center">
        <Image
          src={placeholderImage}
          alt="Рисунок 2-4: Приложение, выполняющее проверку ввода"
          width={600}
          height={400}
          className="mx-auto rounded-md shadow-md"
          data-ai-hint="input validation example"
        />
        <figcaption className="mt-2 text-sm text-muted-foreground">
          <em>Рисунок 2-4: Приложение, выполняющее проверку ввода</em>
        </figcaption>
      </figure>
      <P>
        Во многих случаях приложение может накладывать очень строгие проверки на конкретный элемент ввода. Например, имя пользователя, отправляемое в функцию входа, может иметь максимальную длину в восемь символов и содержать только буквенные символы.
      </P>
      <P>
        В других случаях приложение должно допускать более широкий диапазон возможного ввода. Например, поле адреса, отправляемое на страницу с личными данными, может правомерно содержать буквы, цифры, пробелы, дефисы, апострофы и другие символы. Однако и для этого элемента можно обоснованно ввести ограничения. Данные не должны превышать разумного предела длины (например, 50 символов) и не должны содержать никакой HTML-разметки.
      </P>
      <P>
        В некоторых ситуациях приложению может потребоваться принимать произвольный ввод от пользователей. Например, пользователь блог-платформы может создать блог на тему взлома веб-приложений. Посты и комментарии в блоге могут совершенно законно содержать явные строки атак, которые обсуждаются. Приложению может потребоваться хранить этот ввод в базе данных, записывать на диск и безопасно отображать пользователям. Оно не может просто отклонить ввод только потому, что он выглядит потенциально вредоносным, не снижая при этом значительно ценность приложения для части своей пользовательской базы.
      </P>
      <P>
        В дополнение к различным видам ввода, которые пользователи вводят через интерфейс браузера, типичное приложение получает многочисленные элементы данных, которые изначально были созданы на сервере и отправлены клиенту, чтобы клиент мог передать их обратно на сервер в последующих запросах. Сюда входят такие элементы, как cookie и скрытые поля формы, которые не видны обычным пользователям приложения, но которые злоумышленник, конечно, может просматривать и изменять. В этих случаях приложения часто могут выполнять очень специфическую проверку полученных данных. Например, параметр может требовать одного из определенного набора известных значений, например, cookie, указывающий предпочтительный язык пользователя, или быть в определенном формате, например, номер идентификатора клиента. Более того, когда приложение обнаруживает, что сгенерированные сервером данные были изменены способом, который невозможен для обычного пользователя со стандартным браузером, это часто указывает на то, что пользователь пытается исследовать приложение на наличие уязвимостей. В таких случаях приложение должно отклонить запрос и зарегистрировать инцидент для потенциального расследования (см. раздел «Противодействие злоумышленникам» далее в этой главе).
      </P>

      <H3>Подходы к обработке ввода</H3>
      <P>
        Существуют различные общие подходы к проблеме обработки пользовательского ввода. Разные подходы часто предпочтительны для разных ситуаций и разных типов ввода, и иногда может быть желательна комбинация подходов.
      </P>
      <H3>«Отклонять известное плохое»</H3>
      <P>
        Этот подход обычно использует «черный список», содержащий набор литеральных строк или шаблонов, которые, как известно, используются в атаках. Механизм проверки блокирует любые данные, соответствующие черному списку, и разрешает все остальное.
      </P>
      <P>
        В целом, это считается наименее эффективным подходом к проверке пользовательского ввода по двум основным причинам. Во-первых, типичную уязвимость в веб-приложении можно использовать с помощью широкого спектра входных данных, которые могут быть закодированы или представлены различными способами. За исключением самых простых случаев, вероятно, что черный список пропустит некоторые шаблоны ввода, которые можно использовать для атаки на приложение. Во-вторых, методы эксплуатации постоянно развиваются. Новые методы использования существующих категорий уязвимостей вряд ли будут заблокированы текущими черными списками.
      </P>
      <P>
        Многие фильтры на основе черных списков можно обойти с почти постыдной легкостью, внеся тривиальные изменения в блокируемый ввод. Например:
      </P>
      <Ul items={[
        "Если заблокировано SELECT, попробуйте SeLeCt",
        "Если заблокировано or 1=1--, попробуйте or 2=2--",
        "Если заблокировано alert('xss'), попробуйте prompt('xss')"
      ]} />
      <P>
        В других случаях фильтры, предназначенные для блокировки определенных ключевых слов, можно обойти, используя нестандартные символы между выражениями для нарушения токенизации, выполняемой приложением. Например:
      </P>
      <pre><code className="language-sql">SELECT/*foo*/username,password/*foo*/FROM/*foo*/users</code></pre>
      <P>
        Наконец, многочисленные фильтры на основе черных списков, особенно реализованные в брандмауэрах веб-приложений, были уязвимы для атак с использованием нулевого байта. Из-за различных способов обработки строк в управляемых и неуправляемых контекстах выполнения, вставка нулевого байта в любом месте перед заблокированным выражением может заставить некоторые фильтры прекратить обработку ввода и, следовательно, не идентифицировать выражение. Например:
      </P>
      <pre><code>%00&lt;script&gt;...</code></pre>
      <P>
        Различные другие методы атак на брандмауэры веб-приложений описаны в Главе 18.
      </P>
      <P><strong>ПРИМЕЧАНИЕ:</strong> Атаки, использующие обработку нулевых байтов, возникают во многих областях безопасности веб-приложений. В контекстах, где нулевой байт действует как разделитель строки, его можно использовать для завершения имени файла или запроса к какому-либо бэкенд-компоненту. В контекстах, где нулевые байты допускаются и игнорируются (например, в HTML в некоторых браузерах), произвольные нулевые байты можно вставлять в заблокированные выражения для обхода некоторых фильтров на основе черных списков. Атаки такого рода подробно обсуждаются в последующих главах.</P>
      
      <H3>«Принимать известное хорошее»</H3>
      <P>
        Этот подход использует «белый список», содержащий набор литеральных строк или шаблонов, или набор критериев, которые, как известно, соответствуют только безобидному вводу. Механизм проверки разрешает данные, соответствующие белому списку, и блокирует все остальное.
      </P>
      <P>
        Например, перед поиском запрошенного кода продукта в базе данных приложение может проверить, что он содержит только буквенно-цифровые символы и имеет длину ровно шесть символов. Учитывая последующую обработку, которая будет выполнена с кодом продукта, разработчики знают, что ввод, прошедший этот тест, не может вызвать никаких проблем.
      </P>
      <P>
        В тех случаях, когда этот подход возможен, он считается наиболее эффективным способом обработки потенциально вредоносного ввода. При условии должной осмотрительности при составлении белого списка злоумышленник не сможет использовать специально созданный ввод для вмешательства в поведение приложения. Однако в многочисленных ситуациях приложение должно принимать для обработки данные, которые не соответствуют никаким разумным критериям того, что известно как «хорошее». Например, имена некоторых людей содержат апостроф или дефис. Их можно использовать в атаках на базы данных, но может потребоваться, чтобы приложение разрешало любому регистрироваться под своим настоящим именем. Следовательно, хотя подход на основе белого списка часто чрезвычайно эффективен, он не представляет собой универсального решения проблемы обработки пользовательского ввода.
      </P>

      <H3>Санитизация (Очистка)</H3>
      <P>
        Этот подход признает необходимость иногда принимать данные, которые не могут быть гарантированно безопасными. Вместо того чтобы отклонять этот ввод, приложение очищает его различными способами, чтобы предотвратить любые неблагоприятные последствия. Потенциально вредоносные символы могут быть удалены из данных, оставляя только то, что известно как безопасное, или они могут быть соответствующим образом закодированы или «экранированы» перед дальнейшей обработкой.
      </P>
      <P>
        Подходы, основанные на очистке данных, часто очень эффективны, и во многих ситуациях на них можно положиться как на общее решение проблемы вредоносного ввода. Например, обычной защитой от атак межсайтового скриптинга является HTML-кодирование опасных символов перед их встраиванием в страницы приложения (см. Главу 12). Однако эффективной очистки может быть трудно достичь, если в одном элементе ввода необходимо разместить несколько видов потенциально вредоносных данных. В этой ситуации желателен подход граничной проверки, описанный далее.
      </P>

      <H3>Безопасная обработка данных</H3>
      <P>
        Многие уязвимости веб-приложений возникают из-за небезопасной обработки данных, предоставленных пользователем. Уязвимостей часто можно избежать не путем проверки самого ввода, а путем обеспечения того, чтобы обработка, выполняемая с ним, была по своей сути безопасной. В некоторых ситуациях доступны безопасные методы программирования, которые позволяют избежать распространенных проблем. Например, атаки SQL-инъекций можно предотвратить путем правильного использования параметризованных запросов для доступа к базе данных (см. Главу 9). В других ситуациях функциональность приложения может быть спроектирована таким образом, чтобы избежать по своей сути небезопасных практик, таких как передача пользовательского ввода в интерпретатор команд операционной системы.
      </P>
      <P>
        Этот подход не может быть применен к каждому виду задач, которые должны выполнять веб-приложения. Но там, где он доступен, это эффективный общий подход к обработке потенциально вредоносного ввода.
      </P>

      <H3>Семантические проверки</H3>
      <P>
        Описанные до сих пор средства защиты направлены на защиту приложения от различных видов некорректно сформированных данных, содержимое которых было создано для вмешательства в обработку приложения. Однако при некоторых уязвимостях ввод, предоставленный злоумышленником, идентичен вводу, который может отправить обычный, не злонамеренный пользователь. Вредоносным его делают другие обстоятельства, при которых он отправляется. Например, злоумышленник может попытаться получить доступ к банковскому счету другого пользователя, изменив номер счета, передаваемый в скрытом поле формы. Никакая синтаксическая проверка не отличит данные пользователя от данных злоумышленника. Чтобы предотвратить несанкционированный доступ, приложению необходимо проверить, что отправленный номер счета принадлежит пользователю, который его отправил.
      </P>

      <H3>Граничная проверка</H3>
      <P>
        Идея проверки данных на границах доверия является знакомой. Основная проблема безопасности веб-приложений возникает из-за того, что данные, полученные от пользователей, не заслуживают доверия. Хотя проверки ввода, реализованные на стороне клиента, могут улучшить производительность и удобство для пользователя, они не дают никакой гарантии относительно данных, которые фактически достигают сервера. Точка, в которой данные пользователя впервые принимаются серверным приложением, представляет собой огромную границу доверия. В этой точке приложению необходимо принять меры для защиты от вредоносного ввода.
      </P>
      <P>
        Учитывая характер основной проблемы, заманчиво рассматривать проблему проверки ввода в терминах границы между Интернетом, который «плохой» и не заслуживающий доверия, и серверным приложением, которое «хорошее» и заслуживающее доверия. В этой картине роль проверки ввода заключается в очистке потенциально вредоносных данных при их поступлении и последующей передаче чистых данных доверенному приложению. С этого момента данным можно доверять и обрабатывать их без каких-либо дальнейших проверок или беспокойства о возможных атаках.
      </P>
      <P>
        Как станет очевидно, когда мы начнем изучать некоторые реальные уязвимости, эта простая картина проверки ввода неадекватна по нескольким причинам:
      </P>
      <Ul items={[
        "Учитывая широкий спектр функциональности, которую реализуют приложения, и различные используемые технологии, типичное приложение должно защищаться от огромного разнообразия атак на основе ввода, каждая из которых может использовать разнообразный набор специально созданных данных. Было бы очень трудно разработать единый механизм на внешней границе для защиты от всех этих атак.",
        "Многие функции приложения включают в себя последовательное соединение различных типов обработки. Один фрагмент данных, предоставленных пользователем, может привести к ряду операций в разных компонентах, при этом выходные данные каждого из них используются в качестве входных для следующего. По мере преобразования данных они могут перестать походить на исходные данные. Опытный злоумышленник может манипулировать приложением, чтобы вызвать генерацию вредоносного ввода на ключевом этапе обработки, атакуя компонент, который получает эти данные. Было бы чрезвычайно трудно реализовать механизм проверки на внешней границе, чтобы предвидеть все возможные результаты обработки каждого фрагмента пользовательского ввода.",
        "Защита от разных категорий атак на основе ввода может повлечь за собой выполнение различных проверок пользовательского ввода, которые несовместимы друг с другом. Например, предотвращение атак межсайтового скриптинга может потребовать от приложения HTML-кодирования символа > как &gt;, а предотвращение атак внедрения команд может потребовать от приложения блокировки ввода, содержащего символы & и ;. Попытка предотвратить все категории атак одновременно на внешней границе приложения иногда может быть невозможной."
      ]} />
      <P>
        Более эффективная модель использует концепцию граничной проверки. Здесь каждый отдельный компонент или функциональный блок серверного приложения рассматривает свои входные данные как исходящие из потенциально вредоносного источника. Проверка данных выполняется на каждой из этих границ доверия, в дополнение к внешней границе между клиентом и сервером. Эта модель обеспечивает решение только что описанных проблем. Каждый компонент может защищаться от конкретных типов специально созданного ввода, которым он может быть уязвим. По мере прохождения данных через различные компоненты, проверки могут выполняться в отношении любого значения, которое данные имеют в результате предыдущих преобразований. И поскольку различные проверки реализованы на разных этапах обработки, они вряд ли вступят в конфликт друг с другом.
      </P>
      <P>
        На Рисунке 2-5 показана типичная ситуация, когда граничная проверка является наиболее эффективным подходом к защите от вредоносного ввода. Вход пользователя в систему приводит к выполнению нескольких этапов обработки данных, предоставленных пользователем, и на каждом шаге выполняется соответствующая проверка:
      </P>
      <figure className="my-6 text-center">
        <Image
          src={placeholderImage}
          alt="Рисунок 2-5: Функция приложения, использующая граничную проверку"
          width={600}
          height={400}
          className="mx-auto rounded-md shadow-md"
          data-ai-hint="boundary validation diagram"
        />
        <figcaption className="mt-2 text-sm text-muted-foreground">
          <em>Рисунок 2-5: Функция приложения, использующая граничную проверку на нескольких этапах обработки</em>
        </figcaption>
      </figure>
      <Ul items={[
        "Приложение получает данные для входа пользователя. Обработчик формы проверяет, что каждый элемент ввода содержит только разрешенные символы, находится в пределах определенного лимита длины и не содержит никаких известных сигнатур атак.",
        "Приложение выполняет SQL-запрос для проверки учетных данных пользователя. Для предотвращения атак SQL-инъекций любые символы в пользовательском вводе, которые могут быть использованы для атаки на базу данных, экранируются перед построением запроса.",
        "Если вход успешен, приложение передает определенные данные из профиля пользователя в SOAP-сервис для получения дополнительной информации о ее учетной записи. Для предотвращения атак SOAP-инъекций любые метасимволы XML в данных профиля пользователя соответствующим образом кодируются.",
        "Приложение отображает информацию об учетной записи пользователя обратно в браузер пользователя. Для предотвращения атак межсайтового скриптинга приложение HTML-кодирует любые данные, предоставленные пользователем, которые встраиваются в возвращаемую страницу."
      ]} />
      <P>
        Конкретные уязвимости и средства защиты, задействованные в этом сценарии, будут подробно рассмотрены в последующих главах. Если вариации этой функциональности включали бы передачу данных в другие компоненты приложения, аналогичные средства защиты необходимо было бы реализовать на соответствующих границах доверия. Например, если неудачный вход приводил к отправке предупреждающего электронного письма пользователю, любые пользовательские данные, включенные в электронное письмо, возможно, потребуется проверить на наличие атак SMTP-инъекций.
      </P>

      <H3>Многоэтапная проверка и каноникализация</H3>
      <P>
        Распространенная проблема, с которой сталкиваются механизмы обработки ввода, возникает, когда предоставленные пользователем данные обрабатываются в несколько этапов в рамках логики проверки. Если этот процесс не выполняется тщательно, злоумышленник может создать специально подготовленный ввод, который успешно пронесет вредоносные данные через механизм проверки. Одна из версий этой проблемы возникает, когда приложение пытается очистить пользовательский ввод, удаляя или кодируя определенные символы или выражения. Например, приложение может попытаться защититься от некоторых атак межсайтового скриптинга, удаляя выражение &lt;script&gt;. Если злоумышленник отправит строку &lt;scr&lt;script&gt;ipt&gt;, фильтр проверки может обнаружить и удалить первое вхождение &lt;script&gt;, в результате чего строка &lt;script&gt; будет отправлена приложению для обработки. Существует множество вариаций на эту тему, включающих различные виды кодирования и рекурсивной фильтрации.
      </P>

      <H3>Противодействие злоумышленникам</H3>
      <P>
        Описанные до сих пор защитные меры были сосредоточены на предотвращении успешной эксплуатации злоумышленником распространенных уязвимостей. Они предполагали, что злоумышленник может беспрепятственно исследовать приложение столько, сколько ему угодно, отправляя всевозможные вредоносные данные, а приложение будет делать все возможное, чтобы противостоять. Более надежной системы безопасности можно достичь, если приложение также спроектировано для противодействия самим злоумышленникам.
      </P>
      <P>
        Приложение может противодействовать злоумышленникам различными способами, от пассивных до наступательных:
      </P>
      <Ul items={[
        "Ведение журнала всех значимых событий, связанных с безопасностью",
        "Реагирование на атаки путем оповещения администраторов",
        "Реагирование на атаки путем завершения сессии злоумышленника",
        "Принятие наступательных мер против злоумышленника"
      ]} />

      <H3>Управление приложением</H3>
      <P>
        Последней ключевой областью защитных механизмов приложения является его функциональность управления и администрирования. Для поддержания надежной системы безопасности администраторам необходимо иметь возможность отслеживать состояние и активность приложения, а также управлять ключевыми параметрами конфигурации. Типичные административные функции включают:
      </P>
      <Ul items={[
        "Просмотр информации о пользователях, вошедших в приложение",
        "Доступ к журналам аудита событий, имеющих отношение к безопасности",
        "Настройка механизмов безопасности, таких как правила сложности пароля",
        "Выполнение ключевых административных задач для основной бизнес-функции приложения, таких как рассмотрение и утверждение заявок на кредит или публикация контента на работающем веб-сайте."
      ]} />
    </article>
  );
}
