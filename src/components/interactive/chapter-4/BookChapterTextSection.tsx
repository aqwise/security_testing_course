
'use client';

import { P, H2, H3, Ul } from '@/components/content/ContentPageLayout';
import { CodeBlock } from '@/components/content/CodeBlock';
import Image from 'next/image';

export function BookChapterTextSection() {
  return (
    <article className="prose prose-lg mx-auto max-w-3xl py-8 dark:prose-invert">
      <H2>Глава 4: Картирование приложения</H2>
      <P>
        Первый шаг в процессе атаки на приложение — это сбор и изучение ключевой информации о нем, чтобы лучше понять, с чем вы имеете дело. Процесс картирования начинается с перечисления контента и функциональности приложения, чтобы понять, что оно делает и как себя ведет. Большую часть этой функциональности легко определить, но некоторая ее часть может быть скрыта, и для ее обнаружения потребуется некоторая доля догадок и удачи.
      </P>
      <P>
        После того как каталог функциональности приложения собран, основная задача — внимательно изучить каждый аспект его поведения, его основные механизмы безопасности и используемые технологии (как на стороне клиента, так и на стороне сервера). Это позволит вам определить ключевую поверхность атаки, которую предоставляет приложение, и, следовательно, наиболее интересные области, на которые следует нацелить последующие проверки для поиска уязвимостей, поддающихся эксплуатации.
      </P>
      <P>
        Часто сам процесс анализа может выявить уязвимости, как будет обсуждаться далее в этой главе. По мере того как приложения становятся все больше и функциональнее, эффективное картирование становится ценным навыком. Опытный эксперт может быстро проанализировать целые области функциональности, ища классы уязвимостей, а не отдельные экземпляры, при этом вкладывая значительное время в тестирование других специфических областей с целью обнаружения высокорисковых проблем.
      </P>
      <P>
        В этой главе описываются практические шаги, которые необходимо предпринять при картировании приложения, различные методы и приемы, которые можно использовать для повышения его эффективности, а также некоторые инструменты, которые могут помочь вам в этом процессе.
      </P>

      <H3>Перечисление контента и функциональности</H3>
      <P>
        В типичном приложении большинство контента и функциональности можно определить путем ручного просмотра. Основной подход заключается в том, чтобы пройтись по приложению, начиная с главной страницы, переходя по всем ссылкам и навигируя по всем многоэтапным функциям (таким как регистрация пользователя или сброс пароля). Если в приложении есть «карта сайта», она может стать полезной отправной точкой для перечисления контента.
      </P>
      <P>
        Однако для проведения тщательной проверки перечисленного контента и получения исчерпывающей записи всего, что было определено, необходимо использовать более продвинутые методы, чем простое browsing (просмотр).
      </P>

      <H3>Веб-пауки (Web Spidering)</H3>
      <P>
        Различные инструменты могут выполнять автоматическое сканирование сайтов (spidering). Эти инструменты работают, запрашивая веб-страницу, анализируя ее на наличие ссылок на другой контент, запрашивая эти ссылки и продолжая рекурсивно до тех пор, пока не будет обнаружен новый контент.
      </P>
      <figure className="my-8 text-center">
        <Image
          src="https://placehold.co/800x400.png"
          alt="Схема работы веб-паука: автоматическое сканирование и анализ ссылок на веб-сайте"
          width={800}
          height={400}
          className="rounded-lg shadow-lg mx-auto"
          data-ai-hint="burp suite sitemap"
        />
        <figcaption className="mt-2 text-sm text-muted-foreground italic">
          Рис. 4-1: Картирование части приложения с помощью Burp Spider
        </figcaption>
      </figure>

      <P>
        Опираясь на эту базовую функцию, пауки для веб-приложений пытаются достичь более высокого уровня охвата, также анализируя HTML-формы и отправляя их обратно в приложение с использованием различных предустановленных или случайных значений. Это может позволить им проходить через многоэтапную функциональность и следовать навигации на основе форм (например, когда выпадающие списки используются как меню контента).
      </P>
      <P>
        Некоторые инструменты также анализируют клиентский JavaScript для извлечения URL-адресов, указывающих на дополнительный контент. Существует множество бесплатных инструментов, которые хорошо справляются с перечислением контента и функциональности приложений, включая Burp Suite, WebScarab, Zed Attack Proxy и CAT.
      </P>
      
      <div className="bg-blue-50 dark:bg-blue-900/20 p-4 rounded-lg border-l-4 border-primary my-6">
        <P><strong>ПОДСКАЗКА:</strong> Многие веб-серверы содержат в корневом каталоге файл robots.txt, в котором перечислены URL-адреса, которые сайт не хочет, чтобы посещали веб-пауки или индексировали поисковые системы. Иногда этот файл содержит ссылки на чувствительную функциональность, в сканировании которой вы, безусловно, заинтересованы.</P>
      </div>
      
      <P>
        В этой главе используется вымышленное приложение Extreme Internet Shopping (EIS) для приведения примеров распространенных действий по картированию приложений. Без входа в систему можно составить карту каталога /shop и двух новостных статей в каталоге /media. Также обратите внимание, что файл robots.txt может ссылаться на каталоги, на которые нет ссылок нигде в приложении.
      </P>

      <div className="bg-blue-50 dark:bg-blue-900/20 p-4 rounded-lg border-l-4 border-primary my-6">
        <P><strong>ПОДСКАЗКА:</strong> Приложения, использующие URL-адреса в стиле REST, используют части пути URL-адреса для уникальной идентификации данных и других ресурсов, используемых в приложении. Традиционное представление приложения веб-пауком на основе URL-адресов полезно в таких ситуациях.</P>
      </div>

      <H3>Ограничения автоматизированного сканирования</H3>
      <P>
        Хотя такой полностью автоматизированный подход к перечислению контента часто может быть эффективным, он имеет некоторые существенные ограничения:
      </P>
      <Ul items={[
        "Необычные механизмы навигации (например, меню, динамически создаваемые и обрабатываемые сложным кодом JavaScript) часто не обрабатываются должным образом этими инструментами, поэтому они могут пропустить целые области приложения.",
        "Ссылки, встроенные в скомпилированные клиентские объекты, такие как Flash или Java-апплеты, могут быть не обнаружены пауком.",
        "Многоэтапная функциональность часто реализует тонкие проверки валидации ввода, которые не принимают значения, которые могут быть отправлены автоматическим инструментом.",
        "Автоматические пауки обычно используют URL-адреса в качестве идентификаторов уникального контента. Чтобы избежать бесконечного сканирования, они распознают, когда связанный контент уже был запрошен, и не запрашивают его снова.",
        "Некоторые приложения помещают изменяемые данные в URL-адреса, которые фактически не используются для идентификации ресурсов или функций (например, параметры, содержащие таймеры или случайные числа).",
        "Там, где приложение использует аутентификацию, эффективный паук должен уметь работать с ней, чтобы получить доступ к функциональности, которую защищает аутентификация."
      ]} />
      
      <div className="bg-red-50 dark:bg-red-900/20 p-4 rounded-lg border-l-4 border-destructive my-6">
        <P><strong>ПРЕДУПРЕЖДЕНИЕ:</strong> В некоторых приложениях запуск даже простого веб-паука, который анализирует и запрашивает ссылки, может быть чрезвычайно опасен. Например, приложение может содержать административную функциональность, которая удаляет пользователей, останавливает базу данных, перезагружает сервер и т. д.</P>
      </div>
      
      <H3>Управляемое пользователем сканирование (User-Directed Spidering)</H3>
      <P>
        Это более сложная и контролируемая техника, которая обычно предпочтительнее автоматического сканирования. Здесь пользователь проходит по приложению обычным способом, используя стандартный браузер, пытаясь перемещаться по всей функциональности приложения. При этом результирующий трафик проходит через инструмент, сочетающий в себе перехватывающий прокси и паука, который отслеживает все запросы и ответы.
      </P>
      <figure className="my-8 text-center">
        <Image
          src="https://placehold.co/800x400.png"
          alt="Схема управляемого пользователем сканирования: браузер, прокси-инструмент и целевое приложение"
          width={800}
          height={400}
          className="rounded-lg shadow-lg mx-auto"
          data-ai-hint="proxy architecture diagram"
        />
        <figcaption className="mt-2 text-sm text-muted-foreground italic">
          Рис. 4-2: Карта сайта Burp после выполнения спайдеринга под управлением пользователя
        </figcaption>
      </figure>

      <P>
        Инструмент строит карту приложения, включая все URL-адреса, посещенные браузером. Он также анализирует все ответы приложения так же, как и обычный паук, осведомленный о приложении, и обновляет карту сайта обнаруженным контентом и функциональностью. Пауки в Burp Suite и WebScarab могут использоваться таким образом.
      </P>

      <H3>Преимущества управляемого пользователем сканирования</H3>
      <P>По сравнению с базовым подходом сканирования, эта техника предлагает множество преимуществ:</P>
      <Ul items={[
        "Там, где приложение использует необычные или сложные механизмы навигации, пользователь может следовать им с помощью браузера обычным способом.",
        "Пользователь контролирует все данные, отправляемые в приложение, и может гарантировать соблюдение требований к валидации данных.",
        "Пользователь может войти в приложение обычным способом и обеспечить, чтобы аутентифицированная сессия оставалась активной на протяжении всего процесса картирования.",
        "Любая опасная функциональность полностью перечисляется и включается в карту сайта прокси, но пользователь может по своему усмотрению решать, какие функции действительно запрашивать или выполнять."
      ]} />
      
      <div className="bg-blue-50 dark:bg-blue-900/20 p-4 rounded-lg border-l-4 border-primary my-6">
        <P><strong>ПОДСКАЗКА:</strong> В дополнение к только что описанным инструментам прокси/паука, еще один ряд инструментов, которые часто полезны при картировании приложений, — это различные расширения для браузеров, которые могут выполнять анализ HTTP и HTML прямо из интерфейса браузера.</P>
      </div>

      <H3>Обнаружение скрытого контента</H3>
      <P>
        Часто приложения содержат контент и функциональность, которые не связаны напрямую с основным видимым контентом или не доступны из него. Распространенным примером является функциональность, которая была реализована для целей тестирования или отладки и так и не была удалена.
      </P>
      <P>
        Другой пример возникает, когда приложение предоставляет разную функциональность разным категориям пользователей (например, анонимным пользователям, аутентифицированным обычным пользователям и администраторам). Пользователи одного уровня привилегий, выполняющие исчерпывающее сканирование приложения, могут пропустить функциональность, видимую пользователям других уровней.
      </P>

      <H3>Примеры скрытого контента</H3>
      <P>Существует бесчисленное множество случаев, когда может существовать интересный контент и функциональность:</P>
      <Ul items={[
        "Резервные копии активных файлов. В случае динамических страниц их расширение файла могло быть изменено на то, которое не сопоставлено как исполняемое.",
        "Резервные архивы, содержащие полный снимок файлов в корневом каталоге веба (или даже за его пределами).",
        "Новая функциональность, которая была развернута на сервере для тестирования, но еще не связана ссылками из основного приложения.",
        "Функциональность по умолчанию в готовом приложении, которая была поверхностно скрыта от пользователя, но все еще присутствует на сервере.",
        "Старые версии файлов, которые не были удалены с сервера.",
        "Конфигурационные и включаемые файлы, содержащие чувствительные данные, такие как учетные данные базы данных.",
        "Исходные файлы, из которых была скомпилирована функциональность работающего приложения.",
        "Файлы журналов (log-файлы), которые могут содержать чувствительную информацию, такую как действительные имена пользователей, токены сеансов, посещенные URL-адреса и выполненные действия."
      ]} />

      <H3>Методы перебора (Brute-Force Techniques)</H3>
      <P>
        Автоматизацию можно использовать для выполнения огромного количества запросов к веб-серверу в попытке угадать имена или идентификаторы скрытой функциональности. Burp Intruder можно использовать для перебора списка общих имен каталогов и сбора деталей ответов сервера, которые можно просмотреть для выявления действительных каталогов.
      </P>

      <H3>Интерпретация кодов ответа</H3>
      <P>
        Не предполагайте, что приложение ответит 200 OK, если запрошенный ресурс существует, и 404 Not Found, если его нет. Многие приложения обрабатывают запросы к несуществующим ресурсам индивидуально. Ниже приведено примерное руководство по вероятному значению кодов ответов:
      </P>

      <Ul items={[
        "302 Found — Если перенаправление идет на страницу входа, ресурс может быть доступен только аутентифицированным пользователям.",
        "400 Bad Request — Приложение может использовать собственную схему именования для каталогов и файлов в URL-адресах.",
        "401 Unauthorized или 403 Forbidden — Обычно это указывает на то, что запрошенный ресурс существует, но доступ к нему не может быть получен.",
        "500 Internal Server Error — Во время обнаружения контента это обычно указывает на то, что приложение ожидает отправки определенных параметров при запросе ресурса."
      ]} />

      <H3>Выводы из опубликованного контента</H3>
      <P>
        Большинство приложений используют какую-либо схему именования для своего контента и функциональности. Делая выводы на основе уже определенных ресурсов в приложении, можно точно настроить ваше автоматизированное упражнение по перечислению, чтобы увеличить вероятность обнаружения дополнительного скрытого контента.
      </P>
      <P>
        Часто можно почувствовать привычки разработчиков в именовании, просто прочитав несколько примеров. Например, в зависимости от своего личного стиля, разработчики могут быть многословными, лаконичными, использовать сокращения или даже быть более загадочными. Понимание используемых стилей именования может помочь вам угадать точные имена контента, который вы еще не определили.
      </P>

      <H3>Поиск временных файлов</H3>
      <P>Ищите временные файлы, которые могли быть непреднамеренно созданы инструментами разработки и редакторами файлов:</P>
      <Ul items={[
        "Файл .DS_Store, который содержит индекс каталога в OS X",
        "file.php~1, который является временным файлом, создаваемым при редактировании file.php",
        "Расширение файла .tmp, которое используется множеством программных инструментов"
      ]} />

      <div className="bg-blue-50 dark:bg-blue-900/20 p-4 rounded-lg border-l-4 border-primary my-6">
        <P><strong>ПРИМЕЧАНИЕ:</strong> Вы можете использовать функцию Content Discovery в Burp Suite Pro для автоматизации большинства описанных задач. Burp использует перебор с использованием встроенных списков общих имен файлов и каталогов, динамическую генерацию списков слов на основе имен ресурсов, экстраполяцию имен ресурсов, содержащих числа и даты, и другие методы.</P>
      </div>

      <div className="bg-blue-50 dark:bg-blue-900/20 p-4 rounded-lg border-l-4 border-primary my-6">
        <P><strong>ПОДСКАЗКА:</strong> Проект DirBuster от OWASP также является полезным ресурсом при выполнении задач по автоматическому обнаружению контента. Он включает большие списки имен каталогов, которые были найдены в реальных условиях, упорядоченные по частоте встречаемости.</P>
      </div>
      
      <P>
        Эффективное обнаружение скрытого контента требует сочетания автоматизированных и ручных методов и часто зависит от некоторой доли удачи. Лучший подход — собрать как можно больше информации об ответах приложения во время перебора и просмотреть ее вручную.
      </P>

      <H3>Анализ приложения</H3>
      <P>
        Перечисление как можно большего количества контента приложения — это лишь один из элементов процесса картирования. Не менее важной является задача анализа функциональности приложения, его поведения и используемых технологий с целью определить ключевые поверхности атаки, которые оно предоставляет, и начать формировать подход к исследованию приложения на предмет эксплуатируемых уязвимостей.
      </P>
      <P>
        Вот некоторые ключевые области, которые следует изучить:
      </P>
      <Ul items={[
          "Основная функциональность приложения.",
          "Другое, более периферийное поведение приложения.",
          "Основные механизмы безопасности и то, как они функционируют.",
          "Все различные места, в которых приложение обрабатывает вводимые пользователем данные.",
          "Технологии, применяемые на стороне клиента.",
          "Технологии, применяемые на стороне сервера.",
          "Любые другие детали, которые можно почерпнуть о внутренней структуре и функциональности серверной части приложения."
      ]} />

      <H3>Определение точек входа для пользовательских данных</H3>
      <P>
        Большинство способов, которыми приложение получает пользовательский ввод для серверной обработки, должны быть очевидны при просмотре HTTP-запросов, генерируемых во время обхода функциональности приложения. Вот ключевые места, на которые следует обратить внимание:
      </P>
      <Ul items={[
          "Вся строка URL до разделителя строки запроса (?)",
          "Каждый параметр, передаваемый в строке запроса URL",
          "Каждый параметр, передаваемый в теле POST-запроса",
          "Каждый cookie",
          "Любой другой HTTP-заголовок, который может обрабатывать приложение."
      ]} />
      
      <H3>Определение серверных технологий</H3>
      <P>
        Обычно возможно снять «отпечаток» (fingerprint) технологий, применяемых на сервере, по различным подсказкам и индикаторам.
      </P>

      <H3>Определение серверной функциональности</H3>
      <P>
        Часто можно сделать множество выводов о серверной функциональности и структуре или, по крайней мере, сделать обоснованное предположение, наблюдая за подсказками, которые приложение раскрывает клиенту.
      </P>

      <H3>Картирование поверхности атаки</H3>
      <P>
        Заключительный этап процесса картирования — это определение различных поверхностей атаки, предоставляемых приложением, и потенциальных уязвимостей, которые обычно с ними связаны. Ниже приведено краткое руководство по некоторым ключевым типам поведения и функциональности, которые вы можете выявить, и видам уязвимостей, наиболее часто встречающимся в каждом из них:
      </P>
      <Ul items={[
        "Проверка данных на стороне клиента — Проверки могут не дублироваться на сервере.",
        "Взаимодействие с базой данных — SQL-инъекции.",
        "Загрузка и скачивание файлов — Уязвимости обхода каталога, хранимый межсайтовый скриптинг.",
        "Отображение данных, предоставленных пользователем — Межсайтовый скриптинг.",
        "Использование сторонних компонентов приложений — Известные уязвимости.",
        "Опознаваемое программное обеспечение веб-сервера — Распространенные слабые места в конфигурации, известные баги в ПО."
      ]}/>
      
      <H3>Заключение</H3>
      <P>
        Картирование (Mapping) приложения — это ключевое предварительное условие для его атаки. Может возникнуть соблазн сразу «нырнуть с головой» и начать искать баги, но время, потраченное на получение твердого понимания функциональности приложения, его технологий и поверхности атаки, в конечном итоге принесет свои плоды.
      </P>
    </article>
  );
}
